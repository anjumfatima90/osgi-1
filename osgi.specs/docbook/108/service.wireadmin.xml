<?xml version="1.0" encoding="utf-8"?>
<!--
    Copyright (c) Contributors to the Eclipse Foundation
   
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
   
        http://www.apache.org/licenses/LICENSE-2.0
   
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
   
    SPDX-License-Identifier: Apache-2.0 
 -->

<chapter label="108"
         revision="$Id$"
         version="5.0" xml:id="service.wireadmin"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Wire Admin Service Specification</title>

  <info>
    <releaseinfo><xref endterm="org.osgi.service.wireadmin-version"
    linkend="org.osgi.service.wireadmin"/></releaseinfo>
  </info>

  <section>
    <title>Introduction</title>

    <para>The Wire Admin service is an administrative service that is used to
    control a wiring topology in the OSGi Framework. It is intended to be used
    by user interfaces or management programs that control the wiring of
    services in an OSGi Framework.</para>

    <para>The Wire Admin service plays a crucial role in minimizing the amount
    of context-specific knowledge required by bundles when used in a large
    array of configurations. The Wire Admin service fulfills this role by
    dynamically <emphasis>wiring</emphasis> services together. Bundles
    participate in this wiring process by registering services that produce or
    consume data. The Wire Admin service <emphasis>wires</emphasis> the
    services that produce data to services which consume data.</para>

    <para>The purpose of wiring services together is to allow configurable
    cooperation of bundles in an OSGi Framework. For example, a temperature
    sensor can be connected to a heating module to provide a controlled
    system.</para>

    <para>The Wire Admin service is a very important OSGi configuration
    service and is designed to cooperate closely with the Configuration Admin
    service, as defined in <xref linkend="service.cm"/>.</para>

    <section>
      <title>Wire Admin Service Essentials</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Topology Management</emphasis> - Provide a
          comprehensive mechanism to link data-producing components with
          data-consuming components in an OSGi environment.</para>
        </listitem>

        <listitem>
          <para><emphasis>Configuration Management</emphasis> - Contains
          configuration data in order to allow either party to adapt to the
          special needs of the wire.</para>
        </listitem>

        <listitem>
          <para><emphasis>Data Type Handling</emphasis> - Facilitate the
          negotiation of the data type to be used for data transfer between
          producers of data and consumers of data. Consumers and producers
          must be able to handle multiple data types for data exchanges using
          a preferred order.</para>
        </listitem>

        <listitem>
          <para><emphasis>Composites</emphasis> - Support producers and
          consumers that can handle a large number of data items.</para>
        </listitem>

        <listitem>
          <para><emphasis>Security</emphasis> - Separate connected parties
          from each other. Each party must not be required to hold the service
          object of the other party.</para>
        </listitem>

        <listitem>
          <para><emphasis>Simplicity</emphasis> - The interfaces should be
          designed so that both parties, the Producer and the Consumer
          services, should be easy to implement.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Wire Admin Service Entities</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Producer</emphasis> - A service object that
          generates information to be used by a Consumer service.</para>
        </listitem>

        <listitem>
          <para><emphasis>Consumer</emphasis> - A service object that receives
          information generated by a Producer service.</para>
        </listitem>

        <listitem>
          <para><emphasis>Wire</emphasis> - An object created by the Wire
          Admin service that defines an association between a Producer service
          and a Consumer service. Multiple Wire objects can exist between the
          same Producer and Consumer pair.</para>
        </listitem>

        <listitem>
          <para><emphasis>WireAdmin</emphasis> - The service that provides
          methods to create, update, remove, and list <code>Wire</code>
          objects.</para>
        </listitem>

        <listitem>
          <para><emphasis>WireAdminListener</emphasis> - A service that
          receives events from the Wire Admin service when the
          <code>Wire</code> object is manipulated or used.</para>
        </listitem>

        <listitem>
          <para><emphasis>WireAdminEvent</emphasis> - The event that is sent
          to a <code>WireAdminListener</code> object, describing the details
          of what happened.</para>
        </listitem>

        <listitem>
          <para><emphasis>Configuration Properties</emphasis> - Properties
          that are associated with a <code>Wire</code> object and that contain
          identity and configuration information set by the administrator of
          the Wire Admin service.</para>
        </listitem>

        <listitem>
          <para><emphasis>PID</emphasis> - The Persistent IDentity as defined
          in the Configuration Admin specification.</para>
        </listitem>

        <listitem>
          <para><emphasis>Flavors</emphasis> - The different data types that
          can be used to exchange information between Producer and Consumer
          services.</para>
        </listitem>

        <listitem>
          <para><emphasis>Composite Producer/Consumer</emphasis> - A
          Producer/Consumer service that can generate/accept different kinds
          of values.</para>
        </listitem>

        <listitem>
          <para><emphasis>Envelope</emphasis> - An interface for objects that
          can identify a value that is transferred over the wire.
          <code>Envelope</code> objects contain also a scope name that is used
          to verify access permissions.</para>
        </listitem>

        <listitem>
          <para><emphasis>Scope</emphasis> - A set of names that categorizes
          the kind of values contained in <code>Envelope</code> objects for
          security and selection purposes.</para>
        </listitem>

        <listitem>
          <para><emphasis>Basic Envelope</emphasis> - A concrete
          implementation of the <code>Envelope</code> interface.</para>
        </listitem>

        <listitem>
          <para><emphasis>WirePermission</emphasis> - A Permission sub-class
          that is used to verify if a Consumer service or Producer service has
          permission for specific scope names.</para>
        </listitem>

        <listitem>
          <para><emphasis>Composite Identity</emphasis> - A name that is
          agreed between a composite Consumer and Producer service to identify
          the kind of objects that they can exchange.</para>
        </listitem>
      </itemizedlist>

      <figure pgwide="1">
        <title>Class Diagram, org.osgi.service.wireadmin</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="5.424in"
                       contentwidth="6.500in" fileref="wireadmin-classes.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Operation Summary</title>

      <para>The Wire Admin service maintains a set of persistent
      <code>Wire</code> objects. A <code>Wire</code> object contains a
      Persistent IDentity (PID) for a Consumer service and a PID for a
      Producer service. (<code>Wire</code> objects can therefore be created
      when the Producer or Consumer service is not registered.)</para>

      <para>If both those Producer and Consumer services are registered with
      the Framework, they are connected by the Wire Admin service. The Wire
      Admin service calls a method on each service object and provides the
      list of <code>Wire</code> objects to which they are connected.</para>

      <para>When a Producer service has new information, it should send this
      information to each of the connected <code>Wire</code> objects. Each
      <code>Wire</code> object then must check the filtering and security. If
      both filtering and security allow the transfer, the Producer service
      should inform the associated Consumer service with the new information.
      The Consumer services can also poll a <code>Wire</code> object for an
      new value at any time.</para>

      <para>When a Consumer or Producer service is unregistered from the OSGi
      Framework, the other object in the association is informed that the
      <code>Wire</code> object is no longer valid.</para>

      <para>Administrative applications can use the Wire Admin service to
      create and delete wires. These changes are immediately reflected in the
      current topology and are broadcast to Wire Admin Listener
      services.</para>

      <figure pgwide="1" xml:id="i1276764">
        <title>An Example Wiring Scheme in an OSGi Environment</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="2.621in"
                       contentwidth="7.000in" fileref="wiring-example.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>
  </section>

  <section>
    <title>Producer Service</title>

    <para>A <code>Producer</code> is a service that can produce a sequence of
    data objects. For example, a <code>Producer</code> service can produce,
    among others, the following type of objects:</para>

    <itemizedlist>
      <listitem>
        <para><code>Measurement</code> objects that represent a sensor
        measurement such as temperature, movement, or humidity.</para>
      </listitem>

      <listitem>
        <para>A <code>String</code> object containing information for user
        consumption, such as headlines.</para>
      </listitem>

      <listitem>
        <para>A <code>Date</code> object indicating the occurrence of a
        periodic event.</para>
      </listitem>

      <listitem>
        <para>Position information.</para>
      </listitem>

      <listitem>
        <para><code>Envelope</code> objects containing status items which can
        be any type.</para>
      </listitem>
    </itemizedlist>

    <section>
      <title>Producer Properties</title>

      <para>A Producer service must be registered with the OSGi Framework
      under the interface name
      <code>org.osgi.service.wireadmin.Producer</code>. The following service
      properties must be set:</para>

      <itemizedlist>
        <listitem>
          <para><code>service.pid</code> - The value of this property, also
          known as the PID, defines the Persistent IDentity of a service. A
          Producer service must always use the same PID value whenever it is
          registered. The PID value allows the Wire Admin service to
          consistently identify the Producer service and create a persistent
          <code>Wire</code> object that links a Producer service to a Consumer
          service. See <xref linkend="i1417158"/> specification for the rules
          regarding PIDs.</para>
        </listitem>

        <listitem>
          <para><code>wireadmin.producer.flavors</code> - The value of this
          property is an array of <code>Class</code> objects
          (<code>Class[]</code>) that are the classes of the objects the
          service can produce. See <xref linkend="i1303529"/> for more
          information about the data type negotiation between Producer and
          Consumer services.</para>
        </listitem>

        <listitem>
          <para><code>wireadmin.producer.filters</code> - This property
          indicates to the Wire Admin service that this Producer service
          performs its own update filtering, meaning that the consumer can
          limit the number of update calls with a filter expression. This does
          not modify the data; it only determines whether an update via the
          wire occurs. If this property is not set, the Wire object must
          filter according to the description in <xref linkend="i1269492"/>.
          This service registration property does not need to have a specific
          value.</para>
        </listitem>

        <listitem>
          <para><code>wireadmin.producer.scope</code> - Only for a composite
          Producer service, a list of scope names that define the scope of
          this Producer service, as explained in <xref
          linkend="i1445116"/>.</para>
        </listitem>

        <listitem>
          <para><code>wireadmin.producer.composite</code> - List the composite
          identities of Consumer services with which this Producer service can
          interoperate. This property is of type <code>String[]</code>. A
          composite Consumer service can inter-operate with a composite
          Producer service when there is at least one name that occurs in both
          the Consumer service's array and the Producer service's array for
          this property.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Connections</title>

      <para>The Wire Admin service connects a Producer service and a Consumer
      service by creating a <code>Wire</code> object. If the Consumer and
      Producer services that are bound to a <code>Wire</code> object are
      registered with the Framework, the Wire Admin service must call the
      <xref
      linkend="org.osgi.service.wireadmin.Producer.consumersConnected-Wire---"
      xrefstyle="hyperlink"/> method on the <code>Producer</code> service
      object. Every change in the Wire Admin service that affects the Wire
      object to which a Producer service is connected must result in a call to
      this method. This requirement ensures that the <code>Producer</code>
      object is informed of its role in the wiring topology. If the Producer
      service has no <code>Wire</code> objects attached when it is registered,
      the Wire Admin service must always call
      <code>consumersConnected(null)</code>. This situation implies that a
      Producer service can assume it always gets called back from the Wire
      Admin service when it registers.</para>
    </section>

    <section>
      <title>Producer Example</title>

      <para>The following example shows a clock producer service that sends
      out a <code>Date</code> object every second.</para>

      <programlisting>public class Clock extends Thread implementsProducer {
    Wire          wires[];
    BundleContext context;
    boolean       quit;

    Clock( BundleContext context ) {
        this.context = context;
        start();
    }
    public synchronized void run() {
        Hashtable p = new Hashtable();
        p.put( org.osgi.service.wireadmin.WireConstants.
                        WIREADMIN_PRODUCER_FLAVORS, 
             new Class[] { Date.class } );
        p.put( org.osgi.framework.Constants.SERVICE_PID,
            "com.acme.clock" );
        context.registerService(
            Producer.class.getName(),this,p );

        while( ! quit )
        try {
            Date now = new Date();
            for( int i=0; wires!=null &amp;&amp; i&lt;wires.length;i++ )
                wires[i].update( now );
            wait( 1000 );
        }
        catch( InterruptedException ie) {
            /* will recheck quit */
        }
    }
    public void synchronized consumersConnected(Wire wires[]) 
    {
        this.wires = wires;
    }
    public Object polled(Wire wire) { return new Date(); }
  ...
}</programlisting>
    </section>

    <section>
      <title>Push and Pull</title>

      <para>Communication between Consumer and Producer services can be
      initiated in one of the following ways.</para>

      <itemizedlist>
        <listitem>
          <para>The Producer service calls the <xref
          linkend="org.osgi.service.wireadmin.Wire.update-Object-"
          xrefstyle="hyperlink"/> method on the Wire object. The
          <code>Wire</code> object implementation must then call the <xref
          linkend="org.osgi.service.wireadmin.Consumer.updated-Wire-Object-"
          xrefstyle="hyperlink"/> method on the <code>Consumer</code> service,
          if the filtering allows this.</para>
        </listitem>

        <listitem>
          <para>The <code>Consumer</code> service can call <xref
          linkend="org.osgi.service.wireadmin.Wire.poll--"
          xrefstyle="hyperlink"/> on the <code>Wire</code> object. The
          <code>Wire</code> object must then call <xref
          linkend="org.osgi.service.wireadmin.Producer.polled-Wire-"
          xrefstyle="hyperlink"/> on the <code>Producer</code> object. Update
          filtering must not apply to polling.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Producers and Flavors</title>

      <para>Consumer services can only understand specific data types, and are
      therefore restricted in what data they can process. The acceptable
      object classes, the flavors, are communicated by the Consumer service to
      the Wire Admin service using the Consumer service's service registration
      properties. The method <xref
      linkend="org.osgi.service.wireadmin.Wire.getFlavors--"
      xrefstyle="hyperlink"/> on the <code>Wire</code> object returns this
      list of classes. This list is an ordered list in which the first class
      is the data type that is the most preferred data type supported by the
      Consumer service. The last class is the least preferred data type. The
      Producer service must attempt to convert its data into one of the data
      types according to the preferred order, or will return <code>null</code>
      from the <code>poll</code> method to the Consumer service if none of the
      types are recognized.</para>

      <para>Classes cannot be easily compared for equivalence. Sub-classes and
      interfaces allow classes to masquerade as other classes. The
      <code>Class.isAssignableFrom(Class)</code> method verifies whether a
      class is type compatible, as in the following example:</para>

      <programlisting>Object polled(Wire wire) {
    Class clazzes[] = wire.getFlavors();
    for ( int i=0; i&lt;clazzes.length; i++ ) {
        Class clazz = clazzes[i];
        if ( clazz.isAssignableFrom( Date.class ) )
            return new Date();
        if (    clazz.isAssignableFrom( String.class) )
            return new Date().toString();
    }
    return null;
} </programlisting>

      <para>The order of the <code>if</code> statements defines the
      preferences of the <code>Producer</code> object. Preferred data types
      are checked first. This order normally works as expected but in rare
      cases, sub-classes can change it. Normally, however, that is not a
      problem.</para>
    </section>
  </section>

  <section>
    <title>Consumer Service</title>

    <para>A Consumer service is a service that receives information from one
    or more Producer services and is wired to Producer services by the Wire
    Admin service. Typical Consumer services are as follows:</para>

    <itemizedlist>
      <listitem>
        <para>The control of an actuator, such as a heating element, oven, or
        electric shades</para>
      </listitem>

      <listitem>
        <para>A display</para>
      </listitem>

      <listitem>
        <para>A log</para>
      </listitem>

      <listitem>
        <para>A state controller such as an alarm system</para>
      </listitem>
    </itemizedlist>

    <section>
      <title>Consumer Properties</title>

      <para>A Consumer service must be registered with the OSGi Framework
      under the interface name
      <code>org.osgi.service.wireadmin.Consumer</code>. The following service
      properties must be set:</para>

      <itemizedlist>
        <listitem>
          <para><code>service.pid</code> - The value of this property, also
          known as the PID, defines the Persistent IDentity of a service. A
          Consumer service must always use the same PID value whenever it is
          registered. The PID value allows the Wire Admin service to
          consistently identify the Consumer service and create a persistent
          <code>Wire</code> object that links a Producer service to a Consumer
          service. See the Configuration Admin specification for the rules
          regarding PIDs.</para>
        </listitem>

        <listitem>
          <para><code>wireadmin.consumer.flavors</code> - The value of this
          property is an array of <code>Class</code> objects
          (<code>Class[]</code>) that are the acceptable classes of the
          objects the service can process. See <xref linkend="i1303529"/> for
          more information about the data type negotiation between Producer
          and Consumer services.</para>
        </listitem>

        <listitem>
          <para><code>wireadmin.consumer.scope</code> - Only for a composite
          Consumer service, a list of scope names that define the scope of
          this Consumer service, as explained in <xref
          linkend="i1445116"/>.</para>
        </listitem>

        <listitem>
          <para><code>wireadmin.consumer.composite</code> - List the composite
          identities of Producer services that this Consumer service can
          interoperate with. This property is of type <code>String[]</code>. A
          composite Consumer service can interoperate with a composite
          Producer service when at least one name occurs in both the Consumer
          service's array and the Producer service's array for this
          property.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Connections</title>

      <para>When a <code>Consumer</code> service is registered and a
      <code>Wire</code> object exists that associates it to a registered
      Producer service, the <xref
      linkend="org.osgi.service.wireadmin.Consumer.producersConnected-Wire---"
      xrefstyle="hyperlink"/> method is called on the <code>Consumer</code>
      service.</para>

      <para>Every change in the Wire Admin service that affects a
      <code>Wire</code> object to which a Consumer service is connected must
      result in a call to the <xref
      linkend="org.osgi.service.wireadmin.Consumer.producersConnected-Wire---"
      xrefstyle="hyperlink"/> method. This rule ensures that the Consumer
      object is informed of its role in the wiring topology. If the Consumer
      service has no <code>Wire</code> objects attached, the argument to the
      <xref
      linkend="org.osgi.service.wireadmin.Consumer.producersConnected-Wire---"
      xrefstyle="hyperlink"/> method must be <code>null</code>. This method
      must also be called when a Producer service registers for the first time
      and no <code>Wire</code> objects are available.</para>
    </section>

    <section>
      <title>Consumer Example</title>

      <para>For example, a service can implement a Consumer service that logs
      all objects that are sent to it in order to allow debugging of a wiring
      topology.</para>

      <programlisting>public class LogConsumer implements Consumer{
    public LogConsumer( BundleContext context ) {
        Hashtable ht = new Hashtable();
        ht.put( 
            Constants.SERVICE_PID, "com.acme.logconsumer" );    
        ht.put( WireConstants.WIREADMIN_CONSUMER_FLAVORS,
            new Class[] { Object.class } ); 
        context.registerService( Consumer.class.getName(),
            this, ht );
    }
    public void updated( Wire wire, Object o ) {
        getLog().log( LogService.LOG_INFO, o.toString() );
    }
    public void producersConnected( Wire [] wires) {}
    LogService getLog() { ... }
}</programlisting>
    </section>

    <section>
      <title>Polling or Receiving a Value</title>

      <para>When the <code>Producer</code> service produces a new value, it
      calls the <xref linkend="org.osgi.service.wireadmin.Wire.update-Object-"
      xrefstyle="hyperlink"/> method on the <code>Wire</code> object, which in
      turn calls the <xref
      linkend="org.osgi.service.wireadmin.Consumer.updated-Wire-Object-"
      xrefstyle="hyperlink"/> method on the <code>Consumer</code> service
      object. When the Consumer service needs a value immediately, it can call
      the <xref linkend="org.osgi.service.wireadmin.Wire.poll--"
      xrefstyle="hyperlink"/> method on the <code>Wire</code> object which in
      turn calls the <xref
      linkend="org.osgi.service.wireadmin.Producer.polled-Wire-"
      xrefstyle="hyperlink"/> method on the <code>Producer</code>
      service.</para>

      <para>If the <xref linkend="org.osgi.service.wireadmin.Wire.poll--"
      xrefstyle="hyperlink"/> method on the Wire object is called and the
      Producer is unregistered, it must return a <code>null</code>
      value.</para>
    </section>

    <section>
      <title>Consumers and Flavors</title>

      <para><code>Producer</code> objects send objects of different data types
      through <code>Wire</code> objects. A <code>Consumer</code> service
      object should offer a list of preferred data types (classes) in its
      service registration properties. The Producer service, however, can
      still send a <code>null</code> object or an object that is not of the
      preferred types. Therefore, the <code>Consumer</code> service must check
      the data type and take the appropriate action. If an object type is
      incompatible, then a log message should be logged to allow the operator
      to correct the situation.</para>

      <para>The following example illustrates how a Consumer service can
      handle objects of type <code>Date</code>, <code>Measurement</code>, and
      <code>String</code>.</para>

      <programlisting>void process( Object in ) {
    if ( in instanceof Date )
        processDate( (Date) in );
    else if ( in instanceof Measurement ) 
        processMeasurement( (Measurement) in );
    else if ( in instanceof String ) 
        processString( (String) in );
    else
        processError( in );
}</programlisting>
    </section>
  </section>

  <section>
    <title>Implementation issues</title>

    <para>The Wire Admin service can call the <code>consumersConnected</code>
    or <code>producersConnected</code> methods during the registration of the
    Consumer or Producer service. Care should be taken in this method call so
    that no variables are used that are not yet set, such as the
    <code>ServiceRegistration</code> object that is returned from the
    registration. The same is true for the <code>updated</code> or
    <code>polled</code> callback because setting the <code>Wire</code> objects
    on the Producer service causes such a callback from the
    <code>consumersConnected</code> or <code>producersConnected</code>
    method.</para>

    <para>A Wire Admin service must call the <code>producersConnected</code>
    and <code>consumersConnected</code> method asynchronously from the
    registrations, meaning that the Consumer or Producer service can use
    <code>synchronized</code> to restrict access to critical variables.</para>

    <para>When the Wire Admin service is stopped, it must disconnect all
    connected consumers and producers by calling
    <code>producersConnected</code> and <code>consumersConnected</code> with a
    <code>null</code> for the <code>wires</code> parameter.</para>
  </section>

  <section>
    <title>Wire Properties</title>

    <para>A <code>Wire</code> object has a set of properties (a
    <code>Dictionary</code> object) that configure the association between a
    Consumer service and a Producer service. The type and usage of the keys,
    as well as the allowed types for the values are defined in <xref
    linkend="service.cm.configuration.properties"/>.</para>

    <para>The Wire properties are explained in the following table.</para>

    <table xml:id="service.wireadmin-standard.wire.properties">
      <title>Standard Wire Properties</title>

      <tgroup cols="2">
        <colspec colnum="1" colwidth="2*"/>

        <colspec colnum="2" colwidth="3*"/>

        <thead>
          <row>
            <entry>Constant</entry>

            <entry>Description</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><code>WIREADMIN_PID</code></entry>

            <entry><para>The value of this property is a unique Persistent
            IDentity as defined in chapter <xref linkend="service.cm"/>. This
            PID must be automatically created by the Wire Admin service for
            each new <code>Wire</code> object.</para></entry>
          </row>

          <row>
            <entry><code>WIREADMIN_PRODUCER_PID</code></entry>

            <entry><para>The value of the property is the PID of the
            <code>Producer</code> service.</para></entry>
          </row>

          <row>
            <entry><code>WIREADMIN_CONSUMER_PID</code></entry>

            <entry><para>The value of this property is the PID of the
            <code>Consumer</code> service.</para></entry>
          </row>

          <row>
            <entry><code>WIREADMIN_FILTER</code></entry>

            <entry><para>The value of this property is an OSGi filter string
            that is used to control the update of produced values.
            </para><para>This filter can contain a number of attributes as
            explained in <xref linkend="i1456291"/>.</para></entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>The properties associated with a <code>Wire</code> object are not
    limited to the ones defined in <xref
    linkend="service.wireadmin-standard.wire.properties"/>. The
    <code>Dictionary</code> object can also be used for configuring
    <emphasis>both</emphasis> <code>Consumer</code> services and
    <code>Producer</code> services. Both services receive the
    <code>Wire</code> object and can inspect the properties and adapt their
    behavior accordingly.</para>

    <section>
      <title>Display Service Example</title>

      <para>In the following example, the properties of a <code>Wire</code>
      object, which are set by the Operator or User, are used to configure a
      <code>Producer</code> service that monitors a user's email account
      regularly and sends a message when the user has received email. This
      <code>WireMail</code> service is illustrated as follows:</para>

      <programlisting>public class WireMail extends Thread
    implements Producer {
    Wire           wires[];
    BundleContext  context;
    boolean        quit;

    public void start( BundleContext context ) {
        Hashtable ht = new Hashtable();
        ht.put( Constants.SERVICE_PID, "com.acme.wiremail" );
        ht.put( WireConstants.WIREADMIN_PRODUCER_FLAVORS,
             new Class[] { Integer.class } );
        context.registerService( this, 
            Producer.class.getName(), 
            ht );
    }
    public synchronized void  consumersConnected(
        Wire wires[] ) {
        this.wires = wires;
    }
    public Object polled( Wire wire  ) {
        Dictionary p = wire.getProperties();
        // The password should be
        // obtained from User Admin Service
        int n = getNrMails( 
            p.get( "userid" ),
            p.get( "mailhost" ) );
        return new Integer( n );
    }
    public synchronized void run() {
        while ( !quit ) 
        try {
            for ( int i=0; wires != null &amp;&amp; i&lt;wires.length;i++)
                wires[i].update( polled( wires[i] ) );

            wait( 150000 );
        }
        catch( InterruptedException e ) { break; }
    }
    ...
}</programlisting>
    </section>
  </section>

  <section xml:id="i1269492">
    <title>Composite objects</title>

    <para>A Producer and/or Consumer service for each information item is
    usually the best solution. This solution is not feasible, however, when
    there are hundreds or thousands of information items. Each registered
    Consumer or Producer service carries the overhead of the registration,
    which may overwhelm a Framework implementation on smaller
    platforms.</para>

    <para>When the size of the platform is an issue, a Producer and a Consumer
    service should abstract a larger number of information items. These
    Consumer and Producer services are called
    <emphasis>composite</emphasis>.</para>

    <figure>
      <title>Composite Producer Example</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" contentdepth="0.786in"
                     contentwidth="7.000in" fileref="composite-producer.svg"/>
        </imageobject>
      </mediaobject>
    </figure>

    <para>Composite Producer and Consumer services should register
    respectively the <xref
    linkend="org.osgi.service.wireadmin.WireConstants.WIREADMIN_PRODUCER_COMPOSITE"
    xrefstyle="hyperlink"/> and <xref
    linkend="org.osgi.service.wireadmin.WireConstants.WIREADMIN_CONSUMER_COMPOSITE"
    xrefstyle="hyperlink"/> <emphasis>composite identity</emphasis> property
    with their service registration. These properties should contain a list of
    composite identities. These identities are not defined here, but are up to
    a mutual agreement between the Consumer and Producer service. For example,
    a composite identity could be <code>MOST-1.5</code> or
    <code>GSM-Phase2-Terminal</code>. The name may follow any scheme but will
    usually have some version information embedded. The composite identity
    properties are used to match Consumer and Producer services with each
    other during configuration of the Wire Admin service. A Consumer and
    Producer service should inter-operate when at least one equal composite
    identity is listed in both the Producer and Consumer composite identity
    service property.</para>

    <para>Composite producers/consumers must identify the
    <emphasis>kind</emphasis> of objects that are transferred over the
    <code>Wire</code> object, where <emphasis>kind</emphasis> refers to the
    intent of the object, not the data type. For example, a Producer service
    can represent the status of a door-lock and the status of a window as a
    <code>boolean</code>. If the status of the window is transferred as a
    <code>boolean</code> to the Consumer service, how would it know that this
    <code>boolean</code> represents the window and not the door-lock</para>

    <para>To avoid this confusion, the Wire Admin service includes an
    <code>Envelope</code> interface. The purpose of the <code>Envelope</code>
    interface is to associate a value object with:</para>

    <itemizedlist>
      <listitem>
        <para>An identification object</para>
      </listitem>

      <listitem>
        <para>A scope name</para>
      </listitem>
    </itemizedlist>

    <figure>
      <title>Envelope</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" contentdepth="1.389in"
                     contentwidth="5.922in" fileref="envelope.svg"/>
        </imageobject>
      </mediaobject>
    </figure>

    <section>
      <title>Identification</title>

      <para>The <code>Envelope</code> object's identification object is used
      to identify the value carried in the <code>Envelope</code> object. Each
      unique kind of value must have its own unique identification object. For
      example, a left-front-window should have a different identification
      object than a rear-window.</para>

      <para>The identification is of type <code>Object</code>. Using the
      <code>Object</code> class allows <code>String</code> objects to be used,
      but also makes it possible to use more complex objects. These objects
      can convey information in a way that is mutually agreed between the
      Producer and Consumer service. For example, its type may differ
      depending on each kind of value so that the <emphasis>Visitor</emphasis>
      pattern, see <xref linkend="i1417158"/>, can be used. Or it may contain
      specific information that makes the <code>Envelope</code> object easier
      to dispatch for the Consumer service.</para>
    </section>

    <section xml:id="i1445116">
      <title>Scope</title>

      <para>The scope name is a <code>String</code> object that
      <emphasis>categorizes</emphasis> the <code>Envelope</code> object. The
      scope name is used to limit the kind of objects that can be exchanged
      between composite Producer and Consumer services, depending on security
      settings.</para>

      <para>The name-space for this scope should be mutually agreed between
      the Consumer and Producer services a priori. For the Wire Admin service,
      the scope name is an opaque string. Its syntax is specified in <xref
      linkend="i1425603"/>.</para>

      <para>Both composite Producer and Consumer services must add a list of
      their supported scope names to the service registration properties. This
      list is called the <emphasis>scope</emphasis> of that service. A
      Consumer service must add this scope property with the name of <xref
      linkend="org.osgi.service.wireadmin.WireConstants.WIREADMIN_CONSUMER_SCOPE"
      xrefstyle="hyperlink"/>, a Producer service must add this scope property
      with the name <xref
      linkend="org.osgi.service.wireadmin.WireConstants.WIREADMIN_PRODUCER_SCOPE"
      xrefstyle="hyperlink"/>. The type of this property must be a
      <code>String[]</code> object.</para>

      <para>Not registering this property by the Consumer or the Producer
      service indicates to the Wire Admin service that any <code>Wire</code>
      object connected to that service must return <code>null</code> for the
      <code>Wire.</code><xref
      linkend="org.osgi.service.wireadmin.Wire.getScope--"
      xrefstyle="hyperlink"/> method. This case must be interpreted by the
      Consumer or Producer service that no scope verification is taking place.
      Secure Producer services should not produce values for this
      <code>Wire</code> object and secure Consumer services should not accept
      values.</para>

      <para>It is also allowed to register with a
      <emphasis>wildcard</emphasis>, indicating that all scope names are
      supported. In that case, the <xref
      linkend="org.osgi.service.wireadmin.WireConstants.WIREADMIN_SCOPE_ALL"
      xrefstyle="hyperlink"/> (which is <code>String[] { "*" }</code>) should
      be registered as the scope of the service. The <code>Wire</code>
      object's scope is then fully defined by the other service connected to
      the <code>Wire</code> object.</para>

      <para>The following example shows how a scope is registered.</para>

      <programlisting>static String [] scope = { "DoorLock", "DoorOpen","VIN" };

public void start( BundleContext context ) {
    Dictionary properties = new Hashtable();
    properties.put( 
        WireConstants.WIREADMIN_CONSUMER_SCOPE,
        scope );
    properties.put( WireConstants.WIREADMIN_CONSUMER_PID,
        "com.acme.composite.consumer" );
    properties.put(    
        WireConstants.WIREADMIN_CONSUMER_COMPOSITE,
        new String[] { "OSGiSP-R3" } );
    context.registerService( Consumer.class.getName(),
        new AcmeConsumer(),
        properties );
}</programlisting>

      <para>Both a composite Consumer and Producer service must register a
      scope to receive scope support from the <code>Wire</code> object. These
      two scopes must be converted into a single <code>Wire</code> object's
      scope and scope names in this list must be checked for the appropriate
      permissions. This resulting scope is available from the
      <code>Wire.</code><xref
      linkend="org.osgi.service.wireadmin.Wire.getScope--"
      xrefstyle="hyperlink"/> method.</para>

      <para>If no scope is set by either the Producer or the Consumer service
      the result must be <code>null</code>. In that case, the Producer or
      Consumer service must assume that no security checking is in place. A
      secure Consumer or Producer service should then refuse to operate with
      that <code>Wire</code> object.</para>

      <para>Otherwise, the resulting scope is the intersection of the Consumer
      and Producer service scope where each name in the scope, called
      <code>m</code>, must be implied by a
      <code>WirePermission[m,CONSUME]</code> of the Consumer service, and
      <code>WirePermission[m,PRODUCE]</code> of the Producer service.</para>

      <para>If either the Producer or Consumer service has registered a
      wildcard scope then it must not restrict the list of the other service,
      except for the permission check. If both the Producer and Consumer
      service registered a wild-card, the resulting list must be <xref
      linkend="org.osgi.service.wireadmin.WireConstants.WIREADMIN_SCOPE_ALL"
      xrefstyle="hyperlink"/> ( <code>String[]{"*"}</code>).</para>

      <para>For example, the Consumer service has registered a scope of
      <code>{A,B,C}</code> and has <code>WirePermission[*,CONSUME]</code>. The
      Producer service has registered a scope of <code>{B,C,E}</code> and has
      <code>WirePermission[C|E, PRODUCE,]</code>. The resulting scope is then
      <code>{C}</code>. The following table shows this and more
      examples.</para>

      <table>
        <title>Examples of scope calculation. C=Consumer, P=Producer,
        p=WirePermission, s=scope</title>

        <tgroup cols="5">
          <thead>
            <row>
              <entry>Cs</entry>

              <entry>Cp</entry>

              <entry>Ps</entry>

              <entry>Pp</entry>

              <entry>Wire Scope</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>null</code></entry>

              <entry/>

              <entry><code>null</code></entry>

              <entry/>

              <entry><code>null</code></entry>
            </row>

            <row>
              <entry><code>{A,B,C}</code></entry>

              <entry><code>*</code></entry>

              <entry><code>null</code></entry>

              <entry/>

              <entry><code>null</code></entry>
            </row>

            <row>
              <entry><code>null</code></entry>

              <entry/>

              <entry><code>{C,D,E}</code></entry>

              <entry/>

              <entry><code>null</code></entry>
            </row>

            <row>
              <entry><code>{A,B,C}</code></entry>

              <entry><code>B|C</code></entry>

              <entry><code>{A,B,C}</code></entry>

              <entry><code>A|B</code></entry>

              <entry><code>{B}</code></entry>
            </row>

            <row>
              <entry><code>*</code></entry>

              <entry><code>*</code></entry>

              <entry><code>{A,B,C}</code></entry>

              <entry><code>A|B|C</code></entry>

              <entry><code>{A,B,C}</code></entry>
            </row>

            <row>
              <entry><code>*</code></entry>

              <entry><code>*</code></entry>

              <entry><code>*</code></entry>

              <entry><code>*</code></entry>

              <entry><code>{*}</code></entry>
            </row>

            <row>
              <entry><code>{A,B,C}</code></entry>

              <entry><code>A|B|C</code></entry>

              <entry><code>{A,B,C}</code></entry>

              <entry><code>X</code></entry>

              <entry><code>{}</code></entry>
            </row>

            <row>
              <entry><code>{A,B,C}</code></entry>

              <entry><code>*</code></entry>

              <entry><code>{B,C,E}</code></entry>

              <entry><code>C|E</code></entry>

              <entry><code>{C}</code></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The <code>Wire</code> object's scope must be calculated only once,
      when both the Producer and Consumer service become connected. When a
      Producer or Consumer service subsequently modifies its scope, the Wire
      object must <emphasis>not</emphasis> modify the original scope. A
      Consumer and a Produce service can thus assume that the scope does not
      change after the <code>producersConnected</code> method or
      <code>consumersConnected</code> method has been called.</para>
    </section>

    <section>
      <title>Access Control</title>

      <para>When an <code>Envelope</code> object is used as argument in
      <code>Wire.update(Object)</code> then the <code>Wire</code> object must
      verify that the <code>Envelope</code> object's scope name is included in
      the <code>Wire</code> object's scope. If this is not the case, the
      update must be ignored (the <code>updated</code> method on the Consumer
      service must not be called).</para>

      <para>A composite Producer represents a number of values, which is
      different from a normal Producer that can always return a single object
      from the <code>poll</code> method. A composite Producer must therefore
      return an array of <code>Envelope</code> objects
      (<code>Envelope[]</code>). This array must contain <code>Envelope</code>
      objects for all the values that are in the <code>Wire</code> object's
      scope. It is permitted to return all possible values for the Producer
      because the <code>Wire</code> object must remove all
      <code>Envelope</code> objects that have a scope name not listed in the
      <code>Wire</code> object's scope.</para>
    </section>

    <section>
      <title>Composites and Flavors</title>

      <para>Composite Producer and Consumer services must always use a flavor
      of the <code>Envelope</code> class. The data types of the values must be
      associated with the scope name or identification and mutually agreed
      between the Consumer and Producer services.</para>

      <para>Flavors and <code>Envelope</code> objects both represent
      categories of different values. Flavors, however, are different Java
      classes that represent the same kind of value. For example, the tire
      pressure of the left front wheel could be passed as a
      <code>Float</code>, an <code>Integer</code>, or a
      <code>Measurement</code> object. Whatever data type is chosen, it is
      still the tire pressure of the left front wheel. The
      <code>Envelope</code> object represents the kind of object, for example
      the right front wheel tire pressure, or the left rear wheel.</para>
    </section>

    <section xml:id="i1425603">
      <title>Scope name syntax</title>

      <para>Scope names are normal <code>String</code> objects and can, in
      principle, contain any Unicode character. In use, scope names can be a
      full wildcard ('*') but they cannot be partially wildcarded for matching
      scopes.</para>

      <para>Scope names are used with the <code>WirePermission</code> class
      that extends <code>java.security.BasicPermission</code>. The
      <code>BasicPermission</code> class implements the <code>implies</code>
      method and performs the name matching. The wildcard matching of this
      class is based on the concept of names where the constituents of the
      name are separated with a period (<code>'.'</code>): for example,
      <code>org.osgi.service.http.port</code>.</para>

      <para>Scope names must therefore follow the rules for fully qualified
      Java class names. For example, <code>door.lock</code> is a correct scope
      name while <code>door-lock</code> is not.</para>
    </section>
  </section>

  <section xml:id="i1456291">
    <title>Wire Flow Control</title>

    <para>The <code>WIREADMIN_FILTER</code> property contains a filter
    expression (as defined in the OSGi Framework <code>Filter</code> class)
    that is used to limit the number of updates to the <code>Consumer</code>
    service. This is necessary because information can arrive at a much
    greater rate than can be processed by a <code>Consumer</code> service. For
    example, a single CAN bus (the electronic control bus used in current
    cars) in a car can easily deliver hundreds of measurements per second to
    an OSGi based controller. Most of these measurements are not relevant to
    the OSGi bundles, at least not all the time. For example, a bundle that
    maintains an indicator for the presence of frost is only interested in
    measurements when the outside temperature passes the 4 degrees Celsius
    mark.</para>

    <para>Limiting the number of updates from a Producer service can make a
    significant difference in performance (meaning that less hardware is
    needed). For example, a vendor can implement the filter in native code and
    remove unnecessary updates prior to processing in the Java Virtual Machine
    (JVM). This is depicted in <xref linkend="i1300018"
    xrefstyle="template:Figure %n on page %p"/>.</para>

    <figure pgwide="1" xml:id="i1300018">
      <title>Filtering of Updates</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" contentdepth="2.100in"
                     contentwidth="7.000in" fileref="update-filtering.svg"/>
        </imageobject>
      </mediaobject>
    </figure>

    <para>The filter can use any combination of the following attributes in a
    filter to implement many common filtering schemes:</para>

    <table>
      <title>Filter Attribute Names</title>

      <tgroup cols="2">
        <colspec colnum="1" colwidth="2*"/>

        <colspec colnum="2" colwidth="3*"/>

        <thead>
          <row>
            <entry>Constant</entry>

            <entry>Description</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><code>WIREVALUE_CURRENT</code></entry>

            <entry><para>Current value of the data from the Producer
            service.</para></entry>
          </row>

          <row>
            <entry><code>WIREVALUE_PREVIOUS</code></entry>

            <entry><para>Previous data value that was reported to the Consumer
            service.</para></entry>
          </row>

          <row>
            <entry><code>WIREVALUE_DELTA_ABSOLUTE</code></entry>

            <entry><para>The actual positive difference between the previous
            data value and the current data value. For example, if the
            previous data value was 3 and the current data value is -0.5, then
            the absolute delta is 3.5. This filter attribute is not set when
            the current or previous value is not a number.</para></entry>
          </row>

          <row>
            <entry><code>WIREVALUE_DELTA_RELATIVE</code></entry>

            <entry><para>The absolute (meaning always positive) relative
            change between the current and the previous data values,
            calculated with the following formula:<code>
            |previous-current|/|current|</code>. For example, if the previous
            value was 3 and the new value is 5, then the relative delta is
            <code>|3-5|/|5| = 0.4</code>. This filter attribute is not set
            when the current or previous value is not a number.</para></entry>
          </row>

          <row>
            <entry><code>WIREVALUE_ELAPSED</code></entry>

            <entry><para>The time in milliseconds between the last time the
            <code>Consumer</code>. <xref
            linkend="org.osgi.service.wireadmin.Consumer.updated-Wire-Object-"
            xrefstyle="hyperlink"/> returned and the time the filter is
            evaluated.</para></entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>Filter attributes can be used to implement many common filtering
    schemes that limit the number of updates that are sent to a Consumer
    service. The Wire Admin service specification requires that updates to a
    Consumer service are always filtered if the <code>WIREADMIN_FILTER</code>
    Wire property is present. Producer services that wish to perform the
    filtering themselves should register with a service property
    <code>WIREADMIN_PRODUCER_FILTERS</code>. Filtering must be performed by
    the <code>Wire</code> object for all other Producer services.</para>

    <para>Filtering for composite Producer services is not supported. When a
    filter is set on a <code>Wire</code> object, the Wire must still perform
    the filtering (which is limited to time filtering because an
    <code>Envelope</code> object is not a magnitude), but this approach may
    lose relevant information because the objects are of a different kind. For
    example, an update of every 500 ms could miss all speed updates because
    there is a wheel pressure update that resets the elapsed time. Producer
    services should, however, still implement a filtering scheme that could
    use proprietary attributes to filter on different kind of objects.</para>

    <section>
      <title>Filtering by Time</title>

      <para>The simplest filter mechanism is based on time. The
      <code>wirevalue.elapsed</code> attribute contains the amount of
      milliseconds that have passed since the last update to the associated
      <code>Consumer</code> service. The following example filter expression
      illustrates how the updates can be limited to approximately 40 times per
      minute (once every 1500 ms).</para>

      <programlisting>(wirevalue.elapsed&gt;=1500)</programlisting>

      <para><xref linkend="i1286742"/> depicts this example
      graphically.</para>

      <figure xml:id="i1286742">
        <title>Elapsed Time Change</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.500in"
                       contentwidth="7.000in"
                       fileref="elapsed-time-change.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Filtering by Change</title>

      <para>A Consumer service is often not interested in an update if the
      data value has not changed. The following filter expression shows how a
      Consumer service can limit the updates from a temperature sensor to be
      sent only when the temperature has changed at least 1 °K.</para>

      <programlisting>(wirevalue.delta.absolute&gt;=1)</programlisting>

      <para><xref linkend="i1274545"/> depicts a band that is created by the
      absolute delta between the previous data value and the current data
      value. The Consumer is only notified with the <xref
      linkend="org.osgi.service.wireadmin.Consumer.updated-Wire-Object-"
      xrefstyle="hyperlink"/> method when a data value is outside of this
      band.</para>

      <figure xml:id="i1274545">
        <title>Absolute Delta</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.294in"
                       contentwidth="7.000in" fileref="absolute-delta.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>The delta may also be relative. For example, if a car is moving
      slowly, then updates for the speed of the car are interesting even for
      small variations. When a car is moving at a high rate of speed, updates
      are only interesting for larger variations in speed. The following
      example shows how the updates can be limited to data value changes of at
      least 10%.</para>

      <programlisting>(wirevalue.delta.relative&gt;=0.1)</programlisting>

      <para><xref linkend="i1274674"
      xrefstyle="template:Figure %n on page %p"/> depicts a relative band.
      Notice that the size of the band is directly proportional to the size of
      the sample value.</para>

      <figure xml:id="i1274674">
        <title>Relative Delta (not to scale)</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.192in"
                       contentwidth="7.000in" fileref="relative-delta.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Hysteresis</title>

      <para>A thermostat is a control device that usually has a hysteresis,
      which means that a heater should be switched on below a certain
      specified low temperature and should be switched off at a specified high
      temperature, where <emphasis>high</emphasis> &gt;
      <emphasis>low</emphasis>. This is graphically depicted in <xref
      linkend="i1266957" xrefstyle="template:Figure %n on page %p"/>. The
      specified acceptable temperatures reduce the amount of start/stops of
      the heater.</para>

      <figure xml:id="i1266957">
        <title>Hysteresis</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="1.500in"
                       contentwidth="7.000in" fileref="hysteresis.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>A <code>Consumer</code> service that controls the heater is only
      interested in events at the top and bottom of the hysteresis. If the
      specified high value is 250 °K and the specified low value is 249 °K,
      the following filter illustrates this concept:</para>

      <programlisting>(|(&amp;(wirevalue.previous&lt;=250)(wirevalue.current&gt;250))
    (&amp;(wirevalue.previous&gt;=249)(wirevalue.current&lt;249))
)</programlisting>
    </section>
  </section>

  <section xml:id="i1303529">
    <title>Flavors</title>

    <para>Both <code>Consumer</code> and <code>Producer</code> services should
    register with a property describing the classes of the data types they can
    consume or produce respectively. The classes are the
    <emphasis>flavors</emphasis> that the service supports. The purpose of
    flavors is to allow an administrative user interface bundle to connect
    Consumer and Producer services. Bundles should only create a connection
    when there is at least one class shared between the flavors from a
    Consumer service and a Producer service. Producer services are responsible
    for selecting the preferred object type from the list of the object types
    preferred by the Consumer service. If the Producer service cannot convert
    its data to any of the flavors listed by the Consumer service,
    <code>null</code> should be used instead.</para>
  </section>

  <section>
    <title>Converters</title>

    <para>A converter is a bundle that registers a Consumer and a Producer
    service that are related and performs data conversions. Data values
    delivered to the Consumer service are processed and transferred via the
    related Producer service. The Producer service sends the converted data to
    other Consumer services. This is shown in <xref
    linkend="i1287154"/>.</para>

    <figure xml:id="i1287154">
      <title>Converter (for legend see <xref linkend="i1276764"/> )</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" contentdepth="1.040in"
                     contentwidth="7.000in" fileref="converter.svg"/>
        </imageobject>
      </mediaobject>
    </figure>
  </section>

  <section>
    <title>Wire Admin Service Implementation</title>

    <para>The Wire Admin service is the administrative service that is used to
    control the wiring topology in the OSGi Framework. It contains methods to
    create or update wires, delete wires, and list existing wires. It is
    intended to be used by user interfaces or management programs that control
    the wiring topology of the OSGi Framework.</para>

    <para>The <xref
    linkend="org.osgi.service.wireadmin.WireAdmin.createWire-String-String-Dictionary-"
    xrefstyle="hyperlink"/> method is used to associate a Producer service
    with a Consumer service. The method always creates and returns a new
    object. It is therefore possible to create multiple, distinct wires
    between a Producer and a Consumer service. The properties can be used to
    create multiple associations between Producer and Consumer services in
    that act in different ways.</para>

    <para>The properties of a <code>Wire</code> object can be updated with the
    <xref linkend="org.osgi.service.wireadmin.Wire.update-Object-"
    xrefstyle="hyperlink"/> method. This method must update the properties in
    the Wire object and must notify the associated Consumer and Producer
    services if they are registered. <code>Wire</code> objects that are no
    longer needed can be removed with the <xref
    linkend="org.osgi.service.wireadmin.WireAdmin.deleteWire-Wire-"
    xrefstyle="hyperlink"/> method. All these methods are in the
    <code>WireAdmin</code> class and not in the <code>Wire</code> class for
    security reasons. See <xref linkend="i1287360"/>.</para>

    <para>The <xref
    linkend="org.osgi.service.wireadmin.WireAdmin.getWires-String-"
    xrefstyle="hyperlink"/> method returns an array of <code>Wire</code>
    objects (or <code>null</code>). All objects are returned when the filter
    argument is <code>null</code>. Specifying a filter argument limits the
    returned objects. The filter uses the same syntax as the Framework Filter
    specification. This filter is applied to the properties of the
    <code>Wire</code> object and only <code>Wire</code> objects that match
    this filter are returned.</para>

    <para>The following example shows how the <code>getWires</code> method can
    be used to print the PIDs of <code>Producer</code> services that are wired
    to a specific <code>Consumer</code> service.</para>

    <programlisting>String f = "(wireadmin.consumer.pid=com.acme.x)";
Wire [] wires = getWireAdmin().getWires( f );
for ( int i=0; wires != null &amp;&amp; i &lt; wires.length;i++ )
    System.out.println( 
        wires[i].getProperties().get( 
            "wireadmin.producer.pid") 
    );</programlisting>
  </section>

  <section xml:id="i1622432">
    <title>Wire Admin Listener Service Events</title>

    <para>The Wire Admin service has an extensive list of events that it can
    deliver. The events allow other bundles to track changes in the topology
    as they happen. For example, a graphic user interface program can use the
    events to show when <code>Wire</code> objects become connected, when these
    objects are deleted, and when data flows over a Wire object.</para>

    <para>A bundle that is interested in such events must register a
    <code>WireAdminListener</code> service object with a special
    <code>Integer</code> property <code>WIREADMIN_EVENTS</code> ("
    <code>wireadmin.events</code>"). This <code>Integer</code> object contains
    a bitmap of all the events in which this Wire Admin Listener service is
    interested (events have associated constants that can be ORed together). A
    Wire Admin service must not deliver events to the Wire Admin Listener
    service when that event type is not in the bitmap. If no such property is
    registered, no events are delivered to the Wire Admin Listener
    service.</para>

    <para>The <code>WireAdminListener</code> interface has only one method:
    <xref
    linkend="org.osgi.service.wireadmin.WireAdminListener.wireAdminEvent-WireAdminEvent-"
    xrefstyle="hyperlink"/>. The argument is a <code>WireAdminEvent</code>
    object that contains the event type and associated data.</para>

    <para>A <code>WireAdminEvent</code> object can be sent asynchronously but
    must be ordered for each Wire Admin Listener service. The way events must
    be delivered is the same as described in <emphasis>Delivering
    Events</emphasis> of <xref linkend="intro.core.release"
    xrefstyle="template:%t"/>. Wire Admin Listener services must not assume
    that the state reflected by the event is still true when they receive the
    event.</para>

    <para>The following types are defined for a <code>WireEvent</code>
    object:</para>

    <table>
      <title>Events</title>

      <tgroup cols="2">
        <colspec colnum="1" colwidth="2*"/>

        <colspec colnum="2" colwidth="3*"/>

        <thead>
          <row>
            <entry>Event type</entry>

            <entry>Description</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><code>WIRE_CREATED</code></entry>

            <entry><para>A new <code>Wire</code> object has been
            created.</para></entry>
          </row>

          <row>
            <entry><code>WIRE_CONNECTED</code></entry>

            <entry><para>Both the <code>Producer</code> service and the
            <code>Consumer</code> service are registered but may not have
            executed their respective
            <code>connectedProducers/connectedConsumers</code>
            methods.</para></entry>
          </row>

          <row>
            <entry><code>WIRE_UPDATED</code></entry>

            <entry><para>The <code>Wire</code> object's properties have been
            updated.</para></entry>
          </row>

          <row>
            <entry><code>WIRE_TRACE</code></entry>

            <entry><para>The Consumer has seen a new value, either after the
            Producer service has called the <code>Wire</code>. <xref
            linkend="org.osgi.service.wireadmin.Wire.update-Object-"
            xrefstyle="hyperlink"/> method and the value was not filtered, or
            the <code>Producer</code> service has returned from the <xref
            linkend="org.osgi.service.wireadmin.Producer.polled-Wire-"
            xrefstyle="hyperlink"/> method.</para></entry>
          </row>

          <row>
            <entry><code>WIRE_DISCONNECTED</code></entry>

            <entry><para>The Producer service or Consumer service have become
            unregistered and the <code>Wire</code> object is no longer
            connected.</para></entry>
          </row>

          <row>
            <entry><code>WIRE_DELETED</code></entry>

            <entry><para>The <code>Wire</code> object is deleted from the
            repository and is no longer available from the
            <code>getWires</code> method.</para></entry>
          </row>

          <row>
            <entry><code>CONSUMER_EXCEPTION</code></entry>

            <entry><para>The Consumer service generated an exception and the
            exception is included in the event.</para></entry>
          </row>

          <row>
            <entry><code>PRODUCER_EXCEPTION</code></entry>

            <entry><para>The Producer service generated an exception in a
            callback and the exception is included in the
            event.</para></entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <section>
      <title>Event Admin Service Events</title>

      <para>Wire admin events must be sent asynchronously to the Event Admin
      service by the Wire Admin implementation, if present. The topic of a
      Wire Admin Event is one of the following:</para>

      <programlisting>org/osgi/service/wireadmin/WireAdminEvent/&lt;eventtype&gt;</programlisting>

      <para>The following event types are supported:</para>

      <programlisting>WIRE_CREATED
WIRE_CONNECTED
WIRE_UPDATED
WIRE_TRACE
WIRE_DISCONNECTED
WIRE_DELETED
PRODUCER_EXCEPTION
CONSUMER_EXCEPTION</programlisting>

      <para>The properties of a wire admin event are the following.</para>

      <itemizedlist>
        <listitem>
          <para><code>event</code> - (<code>WireAdminEvent)</code> The
          <code>WireAdminEvent</code> object broadcast by the Wire Admin
          service.</para>
        </listitem>
      </itemizedlist>

      <para>If the <code>getWire</code> method returns a non <code>null</code>
      value:</para>

      <itemizedlist>
        <listitem>
          <para><code>wire</code> - (<code>Wire</code>) The <code>Wire</code>
          object returned by the <code>getWire</code> method.</para>
        </listitem>

        <listitem>
          <para><code>wire.flavors</code> - (<code>String[])</code> The names
          of the classes returned by the <code>Wire</code>
          <code>getFlavors</code> method.</para>
        </listitem>

        <listitem>
          <para><code>wire.scope</code> - (<code>String[])</code> The scope of
          the <code>Wire</code> object, as returned by its
          <code>getScope</code> method.</para>
        </listitem>

        <listitem>
          <para><code>wire.connected</code> - (<code>Boolean)</code> The
          result of the <code>Wire</code> <code>isConnected</code>
          method.</para>
        </listitem>

        <listitem>
          <para><code>wire.valid</code> - (<code>Boolean</code>) The result of
          the <code>Wire isValid</code> method.</para>
        </listitem>
      </itemizedlist>

      <para>If the <code>getThrowable</code> method does not return
      <code>null</code>:</para>

      <itemizedlist>
        <listitem>
          <para><code>exception</code> - (<code>Throwable)</code> The
          Exception returned by the <code>getThrowable</code> method.</para>
        </listitem>

        <listitem>
          <para><code>exception.class</code> - (<code>String)</code> The
          fully-qualified class name of the related Exception.</para>
        </listitem>

        <listitem>
          <para><code>exception.message</code> - (<code>String)</code> The
          message of the related Exception</para>
        </listitem>

        <listitem>
          <para><code>service</code> - (<code>ServiceReference)</code> The
          Service Reference of the Wire Admin service.</para>
        </listitem>

        <listitem>
          <para><code>service.id</code> - (<code>Long)</code> The service id
          of the WireAdmin service.</para>
        </listitem>

        <listitem>
          <para><code>service.objectClass</code> - (<code>String[])</code> The
          Wire Admin service's object class (which must include
          <code>org.osgi.service.wireadmin.WireAdmin</code>)</para>
        </listitem>

        <listitem>
          <para><code>service.pid</code> - (<code>String)</code> The Wire
          Admin service's PID.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Connecting External Entities</title>

    <para>The Wire Admin service can be used to control the topology of
    consumers and producers that are services, as well as external entities.
    For example, a video camera controlled over an IEEE 1394B bus can be
    registered as a Producer service in the Framework's service registry and a
    TV, also connected to this bus, can be registered as a Consumer service.
    It would be very inefficient to stream the video data through the OSGi
    environment. Therefore, the Wire Admin service can be used to supply the
    external addressing information to the camera and the monitor to make a
    direct connection <emphasis>outside</emphasis> the OSGi environment. The
    Wire Admin service provides a uniform mechanism to connect both external
    entities and internal entities.</para>

    <figure>
      <title>Connecting External Entities</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" contentdepth="2.279in"
                     contentwidth="7.000in"
                     fileref="connecting-external-entities.svg"/>
        </imageobject>
      </mediaobject>
    </figure>

    <para>A Consumer service and a Producer service associated with a
    <code>Wire</code> object receive enough information to establish a direct
    link because the PIDs of both services are in the <code>Wire</code>
    object's properties. This situation, however, does not guarantee
    <emphasis>compatibility</emphasis> between Producer and the Consumer
    service. It is therefore recommended that flavors are used to ensure this
    compatibility. Producer services that participate in an external
    addressing scheme, like IEEE 1394B, should have a flavor that reflects
    this address. In this case, there should then for example be a IEEE 1394B
    address class. Consumer services that participate in this external
    addressing scheme should only accept data of this flavor.</para>

    <para>The OSGi <xref linkend="service.device"/>, defines the concept of a
    device category. This is a description of what classes and properties are
    used in a specific device category: for example, a UPnP device category
    that defines the interface that must be used to register for a UPnP
    device, among other things.</para>

    <para>Device category descriptions should include a section that addresses
    the external wiring issue. This section should include what objects are
    send over the wire to exchange addressing information.</para>
  </section>

  <section>
    <title>Related Standards</title>

    <section>
      <title>Java Beans</title>

      <para>The Wire Admin service leverages the component architecture that
      the Framework service registry offers. Java Beans attempt to achieve
      similar goals. Java Beans are classes that follow a number of
      recommendations that allow them to be configured at run time. The
      techniques that are used by Java Beans during configuration are
      serialization and the construction of adapter classes.</para>

      <para>Creating adapter classes in a resource constrained OSGi Framework
      was considered too heavy weight. Also, the dynamic nature of the OSGi
      environment, where services are registered and unregistered
      continuously, creates a mismatch between the intended target area of
      Java Beans and the OSGi Framework.</para>

      <para>Also, Java Beans can freely communicate once they have a reference
      to each other. This freedom makes it impossible to control the
      communication between Java Beans.</para>

      <para>This Wire Admin service specification was developed because it is
      lightweight and leverages the unique characteristics of the OSGi
      Framework. The concept of a <code>Wire</code> object that acts as an
      intermediate between the Producer and Consumer service allows the
      implementation of a security policy because both parties cannot
      communicate directly.</para>
    </section>
  </section>

  <section xml:id="i1287360">
    <title>Security</title>

    <section>
      <title>Separation of Consumer and Producer Services</title>

      <para>The Consumer and Producer service never directly communicate with
      each other. All communication takes place through a <code>Wire</code>
      object. This allows a Wire Admin service implementation to control the
      security aspects of creating a connection, and implies that the Wire
      Admin service must be a trusted service in a secure environment. Only
      one bundle should have the <code>ServicePermission[WireAdmin,
      REGISTER]</code>.</para>

      <para><code>ServicePermission[Producer|Consumer, REGISTER]</code> should
      not be restricted. <code>ServicePermission[Producer|Consumer,GET]</code>
      must be limited to trusted bundles (the Wire Admin service
      implementation) because a bundle with this permission can call such
      services and access information that it should not be able to
      access.</para>
    </section>

    <section>
      <title>Using Wire Admin Service</title>

      <para>This specification assumes that only a few applications require
      access to the Wire Admin service. The <code>WireAdmin</code> interface
      contains all the security sensitive methods that create, update, and
      remove <code>Wire</code> objects. (This is the reason that the update
      and delete methods are on the <code>WireAdmin</code> interface and not
      on the <code>Wire</code> interface).
      <code>ServicePermission[WireAdmin,GET]</code> should therefore only be
      given to trusted bundles that can manage the topology.</para>
    </section>

    <section>
      <title>Wire Permission</title>

      <para>Composite Producer and Consumer services can be restricted in
      their use of scope names. This restriction is managed with the
      <code>WirePermission</code> class. A <code>WirePermission</code>
      consists of a scope name and the action <code>CONSUME</code> or
      <code>PRODUCE</code>. The name used with the <code>WirePermission</code>
      may contain wild-cards as specified in the
      <code>java.security.BasicPermission</code> class.</para>
    </section>
  </section>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.wireadmin.xml"/>

  <section xml:id="service.wireadmin.references">
    <title>References</title>

    <bibliolist>
      <bibliomixed xml:id="i1417158"><title>Design Patterns</title>Erich
      Gamma, Richard Helm, Ralph Johnson, and John Vlissides. Addison Wesley,
      ISBN 0-201-63361</bibliomixed>
    </bibliolist>
  </section>
</chapter>
