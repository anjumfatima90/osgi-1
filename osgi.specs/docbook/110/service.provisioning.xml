<?xml version="1.0" encoding="utf-8"?>
<!--
    Copyright (c) Contributors to the Eclipse Foundation
   
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
   
        http://www.apache.org/licenses/LICENSE-2.0
   
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
   
    SPDX-License-Identifier: Apache-2.0 
 -->

<chapter label="110"
         revision="$Id$"
         version="5.0" xml:id="service.provisioning"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Initial Provisioning Specification</title>

  <info>
    <releaseinfo><xref endterm="org.osgi.service.provisioning-version"
    linkend="org.osgi.service.provisioning"/></releaseinfo>
  </info>

  <section>
    <title>Introduction</title>

    <para>To allow freedom regarding the choice of management protocol, the
    OSGi Specifications assumes an architecture to remotely manage a OSGi
    framework with a Management Agent. The Management Agent is implemented
    with a Management Bundle that can communicate with an unspecified
    management protocol.</para>

    <para>This specification defines how the Management Agent can make its way
    to the OSGi framework, and gives a structured view of the problems and
    their corresponding resolution methods.</para>

    <para>The purpose of this specification is to enable the management of a
    OSGi framework by an Operator, and (optionally) to hand over the
    management of the OSGi framework later to another Operator. This approach
    is in accordance with the OSGi remote management reference
    architecture.</para>

    <para>This bootstrapping process requires the installation of a Management
    Agent, with appropriate configuration data, in the OSGi framework.</para>

    <para>This specification consists of a prologue, in which the principles
    of the Initial Provisioning are outlined, and a number of mappings to
    different mechanisms.</para>

    <section>
      <title>Essentials</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Policy Free</emphasis> - The proposed solution must
          be business model agnostic; none of the affected parties (Operators,
          SPS Manufacturers, etc.) should be forced into any particular
          business model.</para>
        </listitem>

        <listitem>
          <para><emphasis>Interoperability</emphasis> - The Initial
          Provisioning must permit arbitrary interoperability between
          management systems and OSGi frameworks. Any compliant Remote Manager
          should be able to manage any compliant OSGi framework, even in the
          absence of a prior business relationship. Adhering to this
          requirement allows a particular Operator to manage a variety of
          makes and models of OSGi framework Servers using a single management
          system of the Operator's choice. This rule also gives the consumer
          the greatest choice when selecting an Operator.</para>
        </listitem>

        <listitem>
          <para><emphasis>Flexible</emphasis> - The management process should
          be as open as possible, to allow innovation and specialization while
          still achieving interoperability.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Entities</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Provisioning Service</emphasis> - A service
          registered with the Framework that provides information about the
          initial provisioning to the Management Agent.</para>
        </listitem>

        <listitem>
          <para><emphasis>Provisioning Dictionary</emphasis> - A
          <code>Dictionary</code> object that is filled with information from
          the ZIP files that are loaded during initial setup.</para>
        </listitem>

        <listitem>
          <para><emphasis>RSH Protocol</emphasis> - An OSGi specific secure
          protocol based on HTTP.</para>
        </listitem>

        <listitem>
          <para><emphasis>Management Agent</emphasis> - A bundle that is
          responsible for managing a OSGi framework under control of a Remote
          Manager.</para>
        </listitem>
      </itemizedlist>

      <figure pgwide="1">
        <title>Initial Provisioning</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="2.964in"
                       contentwidth="4.937in" fileref="ip-classes.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>
  </section>

  <section xml:id="i1365233">
    <title>Procedure</title>

    <para>The following procedure should be executed by an OSGi Framework
    implementation that supports this Initial Provisioning
    specification.</para>

    <para>When the OSGi framework is first brought under management control,
    it must be provided with an initial request URL in order to be
    provisioned. Either the end user or the manufacturer may provide the
    initial request URL. How the initial request URL is transferred to the
    Framework is not specified, but a mechanism might, for example, be a
    command line parameter when the framework is started.</para>

    <para>When asked to start the Initial Provisioning, the OSGi framework
    will send a request to the management system. This request is encoded in a
    URL, for example:</para>

    <programlisting>http://osgi.acme.com/remote-manager</programlisting>

    <para>This URL may use any protocol that is available on the OSGi
    framework Server. Many standard protocols exist, but it is also possible
    to use a proprietary protocol. For example, software could be present
    which can communicate with a smart card and could handle, for example,
    this URL:</para>

    <programlisting>smart-card://com1:0/7F20/6F38</programlisting>

    <para>Before the request URL is executed, the OSGi framework information
    is appended to the URL. This information includes at least the OSGi
    framework Identifier, but may also contain proprietary information, as
    long as the keys for this information do not conflict. Different URL
    schemes may use different methods of appending parameters; these details
    are specified in the mappings of this specification to concrete
    protocols.</para>

    <para>The result of the request must be a ZIP file. (The content type
    should be <code>application/zip</code>). It is the responsibility of the
    underlying protocol to guarantee the integrity and authenticity of this
    ZIP file.</para>

    <para>This ZIP file is unpacked and its entries (except
    <code>bundle</code> and <code>bundle-url</code> entries, described in
    <xref linkend="service.provisioning-rsh.headers"/> ) are placed in a
    <code>Dictionary</code> object. This <code>Dictionary</code> object is
    called the <emphasis>Provisioning Dictionary</emphasis>. It must be made
    available from the Provisioning Service in the service registry. The names
    of the entries in the ZIP file must not start with a solidus (<code>'/'
    \u002F</code>).</para>

    <para>The ZIP file may contain only four types of dictionary entries:
    <code>text</code>, <code>binary</code>, <code>bundle</code>, or
    <code>bundle-url</code>. The type of an entry can be specified in
    different ways. An Initial Provisioning service must look in the following
    places to find the information about an entry's (MIME) type (in the given
    order):</para>

    <orderedlist>
      <listitem>
        <para>The manifest header <code>InitialProvisioning-Entries</code> of
        the given ZIP file. This header is defined in <xref
        linkend="i1442770"/>. If this header is present, but a given entry's
        path is not named then try the next step.</para>
      </listitem>

      <listitem>
        <para>The extension of the entry path name if one of
        <code>.txt</code>, <code>.jar</code>, <code>.url</code> extensions.
        See <xref linkend="service.provisioning-content.types"
        xrefstyle="template:Table %n on page %p"/> for the mapping of types,
        MIME types, and extensions.</para>
      </listitem>

      <listitem>
        <para>The entry is assumed to be a binary type</para>
      </listitem>
    </orderedlist>

    <para>The types can optionally be specified as a MIME type as defined in
    <xref linkend="i1296602"/>. The <code>text</code> and
    <code>bundle-url</code> entries are translated into a <code>String</code>
    object from an <code>UTF-8</code> encoded byte array. All other entries
    must be stored as a <code>byte[]</code>.</para>

    <table xml:id="service.provisioning-content.types">
      <title>Content types of provisioning ZIP file</title>

      <tgroup cols="4">
        <colspec colnum="1" colwidth="1.5*"/>

        <colspec colnum="2" colwidth="3*"/>

        <colspec colnum="3" colwidth="1*"/>

        <colspec colnum="4" colwidth="4.5*"/>

        <thead>
          <row>
            <entry>Type</entry>

            <entry>MIME Type</entry>

            <entry>Ext</entry>

            <entry>Description</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><code>text</code></entry>

            <entry><para><xref
            linkend="org.osgi.service.provisioning.ProvisioningService.MIME_STRING"
            xrefstyle="hyperlink"/></para><para><code>text/plain;charset=utf-8</code></para></entry>

            <entry><code>.txt</code></entry>

            <entry><para>Must be represented as a String object</para></entry>
          </row>

          <row>
            <entry><code>binary</code></entry>

            <entry><para><xref
            linkend="org.osgi.service.provisioning.ProvisioningService.MIME_BYTE_ARRAY"
            xrefstyle="hyperlink"/></para><para><code>application/octet-stream</code></para></entry>

            <entry><para>not <code>txt</code>, <code>.url</code>, or
            <code>.jar</code></para></entry>

            <entry><para>Must be represented as a byte array
            (<code>byte[]</code>).</para></entry>
          </row>

          <row>
            <entry><code>bundle</code></entry>

            <entry><para><xref
            linkend="org.osgi.service.provisioning.ProvisioningService.MIME_BUNDLE"
            xrefstyle="hyperlink"/></para><para><code>application/vnd.osgi.bundle</code>
            </para><para><code>MIME_BUNDLE_ALT</code></para><para><code>application/x-osgi-bundle</code></para></entry>

            <entry><code>.jar</code></entry>

            <entry><para>Entries must be installed using
            <code>BundleContext.installBundle(String, InputStream)</code>,
            with the <code>InputStream</code> object constructed from the
            contents of the ZIP entry. The location must be the name of the
            ZIP entry without leading solidus (<code>'/' \u002F</code>). This
            entry must not be stored in the Provisioning
            Dictionary.</para><para>If a bundle with this location name is
            already installed in this system, then this bundle must be updated
            instead of installed.</para><para>The <code>MIME_BUNDLE_ALT</code>
            version is intended for backward compatibility, it specifies the
            original MIME type for bundles before there was an official IANA
            MIME type.</para></entry>
          </row>

          <row>
            <entry><code>bundle-url</code></entry>

            <entry><para><xref
            linkend="org.osgi.service.provisioning.ProvisioningService.MIME_BUNDLE_URL"
            xrefstyle="hyperlink"/></para><para><code>text/x-osgi-bundle-url;
            charset=utf-8</code></para></entry>

            <entry><code>.url</code></entry>

            <entry><para>The content of this entry is a string coded in
            <code>utf-8</code>. Entries must be installed using
            <code>BundleContext.installBundle(String, InputStream)</code>,
            with the <code>InputStream</code> object created from the given
            URL. The location must be the name of the ZIP entry without
            leading solidus (<code>'/' \u002F</code>). This entry must not be
            stored in the Provisioning Dictionary.</para><para>If a bundle
            with this location URL is already installed in this system, then
            this bundle must be updated instead of installed.</para></entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>The Provisioning Service must install (but not start) all entries in
    the ZIP file that are typed with <code>bundle</code> or
    <code>bundle-url</code>.</para>

    <para>If an entry named <xref
    linkend="org.osgi.service.provisioning.ProvisioningService.PROVISIONING_START_BUNDLE"
    xrefstyle="hyperlink"/> is present in the Provisioning Dictionary, then
    its content type must be text as defined in <xref
    linkend="service.provisioning-content.types"/>. The content of this entry
    must match the bundle location of a previously loaded bundle. This
    designated bundle must be given <code>AllPermission</code> and
    started.</para>

    <para>If no <xref
    linkend="org.osgi.service.provisioning.ProvisioningService.PROVISIONING_START_BUNDLE"
    xrefstyle="hyperlink"/> entry is present in the Provisioning Dictionary,
    the Provisioning Dictionary should contain a reference to another ZIP file
    under the <xref
    linkend="org.osgi.service.provisioning.ProvisioningService.PROVISIONING_REFERENCE"
    xrefstyle="hyperlink"/> key. If both keys are absent, no further action
    must take place.</para>

    <para>If this <xref
    linkend="org.osgi.service.provisioning.ProvisioningService.PROVISIONING_REFERENCE"
    xrefstyle="hyperlink"/> key is present and holds a <code>String</code>
    object that can be mapped to a valid URL, then a new ZIP file must be
    retrieved from this URL. The <xref
    linkend="org.osgi.service.provisioning.ProvisioningService.PROVISIONING_REFERENCE"
    xrefstyle="hyperlink"/> link may be repeated multiple times in
    successively loaded ZIP files.</para>

    <para>Referring to a new ZIP file with such a URL allows a manufacturer to
    place a fixed reference inside the OSGi framework Server (in a file or
    smart card) that will provide some platform identifying information and
    then also immediately load the information from the management system. The
    <xref
    linkend="org.osgi.service.provisioning.ProvisioningService.PROVISIONING_REFERENCE"
    xrefstyle="hyperlink"/> link may be repeated multiple times in
    successively loaded ZIP files. The entry <xref
    linkend="org.osgi.service.provisioning.ProvisioningService.PROVISIONING_UPDATE_COUNT"
    xrefstyle="hyperlink"/> must be an <code>Integer</code> object that must
    be incremented on every iteration.</para>

    <para>Information retrieved while loading subsequent <xref
    linkend="org.osgi.service.provisioning.ProvisioningService.PROVISIONING_REFERENCE"
    xrefstyle="hyperlink"/> URLs may replace previous key/values in the
    Provisioning Dictionary, but must not erase unrecognized key/values. For
    example, if an assignment has assigned the key <code>proprietary-x</code>,
    with a value '3', then later assignments must not override this value,
    unless the later loaded ZIP file contains an entry with that name. All
    these updates to the Provisioning Dictionary must be stored persistently.
    At the same time, each entry of type <code>bundle</code> or
    <code>bundle-url</code> (see <xref
    linkend="service.provisioning-content.types"/> ) must be installed and not
    started.</para>

    <para>Once the Management Agent has been started, the Initial Provisioning
    service has become operational. In this state, the Initial Provisioning
    service must react when the Provisioning Dictionary is updated with a new
    <xref
    linkend="org.osgi.service.provisioning.ProvisioningService.PROVISIONING_REFERENCE"
    xrefstyle="hyperlink"/> property. If this key is set, it should start the
    cycle again. For example, if the control of a OSGi framework needs to be
    transferred to another Remote Manager, the Management Agent should set the
    <xref
    linkend="org.osgi.service.provisioning.ProvisioningService.PROVISIONING_REFERENCE"
    xrefstyle="hyperlink"/> to the location of this new Remote Manager's
    Initial Provisioning ZIP file. This process is called
    <emphasis>re-provisioning</emphasis>.</para>

    <para>If errors occur during this process, the Initial Provisioning
    service should try to notify the Service User of the problem.</para>

    <para>The previous description is depicted in <xref linkend="i1302126"/>
    as a flow chart.</para>

    <figure xml:id="i1302126">
      <title>Flow chart installation Management Agent bundle</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" contentdepth="3.357in"
                     contentwidth="4.917in" fileref="installation-flow.svg"/>
        </imageobject>
      </mediaobject>
    </figure>

    <para>The Management Agent may require configuration data that is specific
    to the OSGi framework instance. If this data is available outside the
    Management Agent bundle, the merging of this data with the Management
    Agent may take place in the OSGi framework. Transferring the data
    separately will make it possible to simplify the implementation on the
    server side, as it is not necessary to create
    <emphasis>personalized</emphasis> OSGi framework bundles. The <xref
    linkend="org.osgi.service.provisioning.ProvisioningService.PROVISIONING_AGENT_CONFIG"
    xrefstyle="hyperlink"/> key is reserved for this purpose, but the
    Management Agent may use another key or mechanisms if so desired.</para>

    <para>The <xref
    linkend="org.osgi.service.provisioning.ProvisioningService.PROVISIONING_SPID"
    xrefstyle="hyperlink"/> key must contain the OSGi framework
    Identifier.</para>

    <section xml:id="i1442770">
      <title>InitialProvisioning-Entries Manifest Header</title>

      <para>The <code>InitialProvisioning-Entries</code> manifest header
      optionally specifies the type of the entries in the ZIP file. The syntax
      for this header is:</para>

      <programlisting>InitialProvisioning-Entries ::= ip-entry (',' ip-entry ) *
ip-entry                    ::= path ( ';' parameter ) *</programlisting>

      <para>The entry is the path name of a resource in the ZIP file. This
      <code>InitialProvisioning-Entries</code> header recognizes the following
      attribute:</para>

      <itemizedlist>
        <listitem>
          <para><code>type</code> - Gives the type of the dictionary entry.
          The type can have one of the following values: <code>text</code>,
          <code>binary</code>, <code>bundle</code>, or
          <code>bundle-url</code></para>
        </listitem>
      </itemizedlist>

      <para>If the type parameter entry is not specified for an entry, then
      the type will be inferred from the extension of the entry, as defined in
      table <xref linkend="service.provisioning-content.types"
      xrefstyle="template:Table %n on page %p"/>.</para>
    </section>
  </section>

  <section>
    <title>Special Configurations</title>

    <para>The next section shows some examples of specially configured types
    of OSGi framework Servers and how they are treated with the respect to the
    specifications in this document.</para>

    <section>
      <title>Branded OSGi framework Server</title>

      <para>If a OSGi framework Operator is selling OSGi framework Servers
      branded exclusively for use with their service, the provisioning will
      most likely be performed prior to shipping the OSGi framework Server to
      the User. Typically the OSGi framework is configured with the
      <code>Dictionary</code> entry <xref
      linkend="org.osgi.service.provisioning.ProvisioningService.PROVISIONING_REFERENCE"
      xrefstyle="hyperlink"/> pointing at a location controlled by the
      Operator.</para>

      <para>Up-to-date bundles and additional configuration data must be
      loaded from that location at activation time. The OSGi framework is
      probably equipped with necessary security entities, like certificates,
      to enable secure downloads from the Operator's URL over open networks,
      if necessary.</para>
    </section>

    <section>
      <title>Non-connected OSGi framework</title>

      <para>Circumstances might exist in which the OSGi framework Server has
      no WAN connectivity, or prefers not to depend on it for the purposes not
      covered by this specification.</para>

      <para>The non-connected case can be implemented by specifying a
      <code>file://</code> URL for the initial ZIP file ( <xref
      linkend="org.osgi.service.provisioning.ProvisioningService.PROVISIONING_REFERENCE"
      xrefstyle="hyperlink"/> ). That <code>file://</code> URL would name a
      local file containing the response that would otherwise be received from
      a remote server.</para>

      <para>The value for the Management Agent <xref
      linkend="org.osgi.service.provisioning.ProvisioningService.PROVISIONING_REFERENCE"
      xrefstyle="hyperlink"/> found in that file will be used as input to the
      load process. The <xref
      linkend="org.osgi.service.provisioning.ProvisioningService.PROVISIONING_REFERENCE"
      xrefstyle="hyperlink"/> may point to a bundle file stored either locally
      or remotely. No code changes are necessary for the non-connected
      scenario. The <code>file://</code> URLs must be specified, and the
      appropriate files must be created on the OSGi framework.</para>
    </section>
  </section>

  <section>
    <title>The Provisioning Service</title>

    <para>Provisioning information is conveyed between bundles using the
    Provisioning Service, as defined in the <xref
    linkend="org.osgi.service.provisioning.ProvisioningService"
    xrefstyle="hyperlink"/> interface. The Provisioning Dictionary is
    retrieved from the <code>ProvisioningService</code> object using the <xref
    linkend="org.osgi.service.provisioning.ProvisioningService.getInformation--"
    xrefstyle="hyperlink"/> method. This is a read-only
    <code>Dictionary</code> object, any changes to this
    <code>Dictionary</code> object must throw an
    <code>UnsupportedOperationException</code>.</para>

    <para>The Provisioning Service provides a number of methods to update the
    Provisioning Dictionary.</para>

    <itemizedlist>
      <listitem>
        <para><xref
        linkend="org.osgi.service.provisioning.ProvisioningService.addInformation-Dictionary-"
        xrefstyle="hyperlink"/> - Add all key/value pairs in the given
        <code>Dictionary</code> object to the Provisioning Dictionary.</para>
      </listitem>

      <listitem>
        <para><xref
        linkend="org.osgi.service.provisioning.ProvisioningService.addInformation-ZipInputStream-"
        xrefstyle="hyperlink"/> - It is also possible to add a ZIP file to the
        Provisioning Service immediately. This will unpack the ZIP file and
        add the entries to the Provisioning Dictionary. This method must
        install the bundles contained in the ZIP file as described in <xref
        linkend="i1365233"/>.</para>
      </listitem>

      <listitem>
        <para><xref
        linkend="org.osgi.service.provisioning.ProvisioningService.setInformation-Dictionary-"
        xrefstyle="hyperlink"/> - Set a new Provisioning Dictionary. This will
        remove all existing entries.</para>
      </listitem>
    </itemizedlist>

    <para>Each of these method will increment the <xref
    linkend="org.osgi.service.provisioning.ProvisioningService.PROVISIONING_UPDATE_COUNT"
    xrefstyle="hyperlink"/> entry.</para>
  </section>

  <section>
    <title>Management Agent Environment</title>

    <para>The Management Agent should be written with great care to minimize
    dependencies on other packages and services, as <emphasis>all</emphasis>
    services in OSGi are optional. Some OSGi frameworks may have other bundles
    pre-installed, so it is possible that there may be exported packages and
    services available. Mechanisms outside the current specification, however,
    must be used to discover these packages and services before the Management
    Agent is installed.</para>

    <para>The Provisioning Service must ensure that the Management Agent is
    running with <code>AllPermission</code>. The Management Agent should check
    to see if the Permission Admin service is available, and establish the
    initial permissions as soon as possible to insure the security of the
    device when later bundles are installed. As the
    <code>PermissionAdmin</code> interfaces may not be present (it is an
    optional service), the Management Agent should export the
    <code>PermissionAdmin</code> interfaces to ensure they can be
    resolved.</para>

    <para>Once started, the Management Agent may retrieve its configuration
    data from the Provisioning Service by getting the <code>byte[]</code>
    object that corresponds to the <xref
    linkend="org.osgi.service.provisioning.ProvisioningService.PROVISIONING_AGENT_CONFIG"
    xrefstyle="hyperlink"/> key in the Provisioning Dictionary. The structure
    of the configuration data is implementation specific.</para>

    <para>The scope of this specification is to provide a mechanism to
    transmit the raw configuration data to the Management Agent. The
    Management Agent bundle may alternatively be packaged with its
    configuration data in the bundle, so it may not be necessary for the
    Management Agent bundle to use the Provisioning Service at all.</para>

    <para>Most likely, the Management Agent bundle will install other bundles
    to provision the OSGi framework. Installing other bundles might even
    involve downloading a more full featured Management Agent to replace the
    initial Management Agent.</para>
  </section>

  <section>
    <title>Mapping To File Scheme</title>

    <para>The <code>file:</code> scheme is the simplest and most completely
    supported scheme which can be used by the Initial Provisioning
    specification. It can be used to store the configuration data and
    Management Agent bundle on the OSGi framework Server, and avoids any
    outside communication.</para>

    <para>If the initial request URL has a <code>file</code> scheme, no
    parameters should be appended, because the <code>file:</code> scheme does
    not accept parameters.</para>

    <section>
      <title>Example With File Scheme</title>

      <para>The manufacturer should prepare a ZIP file containing only one
      entry named <xref
      linkend="org.osgi.service.provisioning.ProvisioningService.PROVISIONING_START_BUNDLE"
      xrefstyle="hyperlink"/> that contains a location string of an entry of
      type <code>bundle</code> or <code>bundle-url</code>. For example, the
      following ZIP file demonstrates this:</para>

      <programlisting>provisioning.start.bundle  text        agent
agent                      bundle      C0AF0E9B2AB..</programlisting>

      <para>The bundle may also be specified with a URL:</para>

      <programlisting>provisioning.start.bundle  text        http://acme.com/a.jar
agent                      bundle-url  http://acme.com/a.jar</programlisting>

      <para>Upon startup, the framework is provided with the URL with the
      <code>file:</code> scheme that points to this ZIP file:</para>

      <programlisting>file:/opt/osgi/ma.zip</programlisting>
    </section>
  </section>

  <section>
    <title>Mapping To HTTP(S) Scheme</title>

    <para>This section defines how HTTP and HTTPS URLs must be used with the
    Initial Provisioning specification.</para>

    <itemizedlist>
      <listitem>
        <para>HTTP - May be used when the data exchange takes place over
        networks that are secured by other means, such as a Virtual Private
        Network (VPN) or a physically isolated network. Otherwise, HTTP is not
        a valid scheme because no authentication takes place.</para>
      </listitem>

      <listitem>
        <para>HTTPS - May be used if the OSGi framework is equipped with
        appropriate certificates.</para>
      </listitem>
    </itemizedlist>

    <para>HTTP and HTTPS share the following qualities:</para>

    <itemizedlist>
      <listitem>
        <para>Both are well known and widely used</para>
      </listitem>

      <listitem>
        <para>Numerous implementations of the protocols exist</para>
      </listitem>

      <listitem>
        <para>Caching of the Management Agent will be desired in many
        implementations where limited bandwidth is an issue. Both HTTP and
        HTTPS already contain an accepted protocol for caching.</para>
      </listitem>
    </itemizedlist>

    <para>Both HTTP and HTTPS must be used with the GET method. The response
    is a ZIP file, implying that the response header <code>Content-Type</code>
    header must contain <code>application/zip</code>.</para>

    <section>
      <title>HTTPS Certificates</title>

      <para>In order to use HTTPS, certificates must be in place. These
      certificates, that are used to establish trust towards the Operator, may
      be made available to the OSGi framework using the Provisioning Service.
      The root certificate should be assigned to the Provisioning Dictionary
      before the HTTPS provider is used. Additionally, the OSGi framework
      should be equipped with a OSGi framework certificate that allows the
      OSGi framework to properly authenticate itself towards the Operator.
      This specification does not state how this certificate gets installed
      into the OSGi framework.</para>

      <para>The root certificate is stored in the Provisioning Dictionary
      under the key:</para>

      <programlisting><xref
          linkend="org.osgi.service.provisioning.ProvisioningService.PROVISIONING_ROOTX509"
          xrefstyle="hyperlink"/></programlisting>

      <para>The Root X.509 Certificate holds certificates used to represent a
      handle to a common base for establishing trust. The certificates are
      typically used when authenticating a Remote Manager to the OSGi
      framework. In this case, a Root X.509 certificate must be part of a
      certificate chain for the Operator's certificate. The format of the
      certificate is defined in <xref linkend="i1287116"/>.</para>
    </section>

    <section xml:id="i1287116">
      <title>Certificate Encoding</title>

      <para>Root certificates are X.509 certificates. Each individual
      certificate is stored as a <code>byte[]</code> object. This
      <code>byte[]</code> object is encoded in the default Java manner, as
      follows:</para>

      <itemizedlist>
        <listitem>
          <para>The original, binary certificate data is DER encoded</para>
        </listitem>

        <listitem>
          <para>The DER encoded data is encoded into base64 to make it
          text.</para>
        </listitem>

        <listitem>
          <para>The base64 encoded data is prefixed with</para>

          <para><programlisting>-----BEGIN CERTIFICATE-----</programlisting></para>

          <para>and suffixed with:</para>

          <para><programlisting>-----END CERTIFICATE-----</programlisting></para>
        </listitem>

        <listitem>
          <para>If a record contains more than one certificate, they are
          simply appended one after the other, each with a delimiting prefix
          and suffix.</para>
        </listitem>
      </itemizedlist>

      <para xml:id="i1323445">The decoding of such a certificate may be done
      with the <code>java.security.cert.CertificateFactory</code>
      class:</para>

      <programlisting>InputStream bis = new ByteArrayInputStream(x509);// byte[]
CertificateFactory cf = 
    CertificateFactory.getInstance("X.509");
Collection c = cf.generateCertificates(bis); 
Iterator i = c.iterator(); 
while (i.hasNext()) { 
    Certificate cert = (Certificate)i.next();
    System.out.println(cert); 
} </programlisting>
    </section>

    <section xml:id="i1297554">
      <title>URL Encoding</title>

      <para>The URL must contain the OSGi framework Identity, and may contain
      more parameters. These parameters are encoded in the URL according to
      the HTTP(S) URL scheme. A base URL may be set by an end user but the
      Provisioning Service must add the OSGi framework Identifier.</para>

      <para>If the request URL already contains HTTP parameters (if there is a
      '?' in the request), the <code>service_platform_id</code> is appended to
      this URL as an additional parameter. If, on the other hand, the request
      URL does not contain any HTTP parameters, the
      <code>service_platform_id</code> will be appended to the URL after a
      '?', becoming the first HTTP parameter. The following two examples show
      these two variants:</para>

      <programlisting>http://server.operator.com/service-x? «
    foo=bar&amp;service_platform_id=VIN:123456789

http://server.operator.com/service-x? «
    service_platform_id=VIN:123456789</programlisting>

      <para>Proper URL encoding must be applied when the URL contains
      characters that are not allowed. See <xref linkend="i1297476"/>.</para>
    </section>
  </section>

  <section>
    <title>Mapping To RSH Scheme</title>

    <para>The RSH protocol is an OSGi-specific protocol, and is included in
    this specification because it is optimized for Initial Provisioning. It
    requires a shared secret between the management system and the OSGi
    framework that is small enough to be entered by the Service User.</para>

    <para>RSH bases authentication and encryption on Message Authentication
    Codes (MACs) that have been derived from a secret that is shared between
    the OSGi framework and the Operator prior to the start of the protocol
    execution.</para>

    <para>The protocol is based on an ordinary HTTP GET request/response, in
    which the request must be <emphasis>signed</emphasis> and the response
    must be <emphasis>encrypted</emphasis> and
    <emphasis>authenticated</emphasis>. Both the
    <emphasis>signature</emphasis> and <emphasis>encryption key</emphasis> are
    derived from the shared secret using Hashed Message Access Codes (HMAC)
    functions.</para>

    <para>As additional input to the HMAC calculations, one client-generated
    nonce and one server-generated nonce are used to prevent replay attacks.
    The nonces are fairly large random numbers that must be generated in
    relation to each invocation of the protocol, in order to guarantee
    freshness. These nonces are called <code>clientfg</code> (client-generated
    freshness guarantee) and <code>serverfg</code> (server-generated freshness
    guarantee).</para>

    <para>In order to separate the HMAC calculations for authentication and
    encryption, each is based on a different constant value. These constants
    are called the <emphasis>authentication constant</emphasis> and the
    <emphasis>encryption constant</emphasis>.</para>

    <para>From an abstract perspective, the protocol may be described as
    follows.</para>

    <itemizedlist>
      <listitem>
        <para><phrase role="symbol">δ</phrase> - Shared secret, 160 bits or
        more</para>
      </listitem>

      <listitem>
        <para><emphasis>s</emphasis> - Server nonce, called
        <code>servercfg</code>, 128 bits</para>
      </listitem>

      <listitem>
        <para><emphasis>c</emphasis> - Client nonce, called
        <code>clientfg</code>, 128 bits</para>
      </listitem>

      <listitem>
        <para><emphasis>K</emphasis><subscript>a</subscript> - Authentication
        key, 160 bits</para>
      </listitem>

      <listitem>
        <para><emphasis>K</emphasis><subscript>e</subscript> - Encryption key,
        192 bits</para>
      </listitem>

      <listitem>
        <para><emphasis>r</emphasis> - Response data</para>
      </listitem>

      <listitem>
        <para><emphasis>e</emphasis> - Encrypted data</para>
      </listitem>

      <listitem>
        <para><emphasis>E</emphasis> - Encryption constant, a
        <code>byte[]</code> of 05, 36, 54, 70, 00 (hex)</para>
      </listitem>

      <listitem>
        <para><emphasis>A</emphasis> - Authentication constant, a
        <code>byte[]</code> of 00, 4f, 53, 47, 49 (hex)</para>
      </listitem>

      <listitem>
        <para><emphasis>M</emphasis> - Message material, used for
        K<subscript>e</subscript> calculation.</para>
      </listitem>

      <listitem>
        <para><emphasis>m</emphasis> - The calculated message authentication
        code.</para>
      </listitem>

      <listitem>
        <para><emphasis>3DES</emphasis> - Triple DES, encryption function, see
        <xref linkend="i1326320"/>. The bytes of the key must be set to odd
        parity. CBC mode must be used where the padding method is defined in
        <xref linkend="i1371344"/>. In <xref linkend="i1371440"/> this is
        addressed as <code>PKCS5Padding</code>.</para>
      </listitem>

      <listitem>
        <para><emphasis>IV</emphasis> - Initialization vector for 3DES.</para>
      </listitem>

      <listitem>
        <para><emphasis>SHA1</emphasis> - Secure Hash Algorithm to generate
        the Hashed Message Authentication Code, see <xref
        linkend="i1371220"/>. The function takes a single parameter, the block
        to be worked upon.</para>
      </listitem>

      <listitem>
        <para><emphasis>HMAC</emphasis> - The function that calculates a
        message authentication code, which must HMAC-SHA1. HMAC-SHA1 is
        defined in <xref linkend="i1327494"/>. The HMAC function takes a key
        and a block to be worked upon as arguments. Note that the lower 16
        bytes of the result must be used.</para>
      </listitem>

      <listitem>
        <para><emphasis>{}</emphasis> - Concatenates its arguments</para>
      </listitem>

      <listitem>
        <para><emphasis>[]</emphasis> - Indicates access to a sub-part of a
        variable, in bytes. Index starts at one, not zero.</para>
      </listitem>
    </itemizedlist>

    <para>In each step, the emphasized server or client indicates the context
    of the calculation. If both are used at the same time, each variable will
    have server or client as a subscript.</para>

    <orderedlist>
      <listitem>
        <para>The <emphasis>client</emphasis> generates a random nonce, stores
        it and denotes it <code>clientfg</code></para>

        <para><emphasis>c = nonce</emphasis></para>
      </listitem>

      <listitem>
        <para>The client sends the request with the <code>clientfg</code> to
        the server.</para>

        <para><emphasis>c</emphasis><subscript>server</subscript> <phrase
        role="symbol">⇐</phrase>
        <emphasis>c</emphasis><subscript>client</subscript></para>
      </listitem>

      <listitem>
        <para>The <emphasis>server</emphasis> generates a nonce and denotes it
        <code>serverfg</code>.</para>

        <para><emphasis>s = nonce</emphasis></para>
      </listitem>

      <listitem>
        <para>The <emphasis>server</emphasis> calculates an authentication key
        based on the SHA1 function, the shared secret, the received
        <code>clientfg</code>, the <code>serverfg</code> and the
        authentication constant.</para>

        <para><emphasis>K</emphasis><subscript>a</subscript> <phrase
        role="symbol">←</phrase> <emphasis>SHA1</emphasis>({<phrase
        role="symbol">δ</phrase>, <emphasis>c</emphasis>,
        <emphasis>s</emphasis>, <emphasis>A</emphasis>})</para>
      </listitem>

      <listitem xml:id="i1325557">
        <para>The <emphasis>server</emphasis> calculates an encryption key
        using an SHA-1 function, the shared secret, the received
        <code>clientfg</code>, the <code>serverfg</code> and the encryption
        constant. It must first calculate the <emphasis>key
        material</emphasis> M.</para>

        <para><emphasis>M</emphasis>[1, 20] <phrase role="symbol">←</phrase>
        <emphasis>SHA1</emphasis>({ <phrase role="symbol">δ</phrase>,
        <emphasis>c</emphasis>, <emphasis>s</emphasis>,
        <emphasis>E</emphasis>})</para>

        <para><emphasis>M</emphasis>[21, 40] <phrase role="symbol">←</phrase>
        <emphasis>SHA1</emphasis>({ <phrase role="symbol">δ</phrase>,
        <emphasis>M</emphasis>[1, 20], <emphasis>c</emphasis>,
        <emphasis>s</emphasis>, <emphasis>E</emphasis>})</para>
      </listitem>

      <listitem xml:id="i1325580">
        <para>The key for DES consists K<subscript>e</subscript> and
        IV.</para>

        <para><emphasis>K</emphasis><subscript>e</subscript> <phrase
        role="symbol">←</phrase> <emphasis>M</emphasis>[1, 24]</para>

        <para><emphasis>IV</emphasis> <phrase role="symbol">←</phrase>
        <emphasis>M</emphasis>[25, 32]</para>

        <para>The <emphasis>server</emphasis> encrypts the response data using
        the encryption key derived in step <xref linkend="i1325557"/>. The
        encryption algorithm that must be used to encrypt/decrypt the response
        data is 3DES. 24 bytes (192 bits) from M are used to generate
        K<subscript>e</subscript>, but the low order bit of each byte must be
        used as an odd parity bit. This means that before using
        K<subscript>e</subscript>, each byte must be processed to set the low
        order bit so that the byte has odd parity.</para>

        <para>The encryption/decryption key used is specified by the
        following:</para>

        <para><emphasis>e</emphasis> <phrase role="symbol">←</phrase>
        <emphasis>3DES</emphasis>(
        <emphasis>K</emphasis><subscript>e</subscript>,
        <emphasis>IV</emphasis>, <emphasis>r</emphasis>)</para>
      </listitem>

      <listitem>
        <para>The <emphasis>server</emphasis> calculates a MAC
        <emphasis>m</emphasis> using the HMAC function, the encrypted response
        data and the authentication key derived in 4.</para>

        <para><emphasis>m</emphasis> <phrase role="symbol">←</phrase>
        <emphasis>HMAC</emphasis>(
        <emphasis>K</emphasis><subscript>a</subscript>,
        <emphasis>e</emphasis>)</para>
      </listitem>

      <listitem>
        <para>The <emphasis>server</emphasis> sends a response to the
        <emphasis>client</emphasis> containing the <code>serverfg</code>, the
        MAC <emphasis>m</emphasis> and the encrypted response data</para>

        <para><emphasis>s</emphasis><subscript>client</subscript> <phrase
        role="symbol">⇐</phrase>
        <emphasis>s</emphasis><subscript>server</subscript></para>

        <para><emphasis>m</emphasis><subscript>client</subscript> <phrase
        role="symbol">⇐</phrase>
        <emphasis>m</emphasis><subscript>server</subscript></para>

        <para><emphasis>e</emphasis><subscript>client</subscript> <phrase
        role="symbol">⇐</phrase>
        <emphasis>e</emphasis><subscript>server</subscript></para>

        <para>The <emphasis>client</emphasis> calculates the encryption key
        K<subscript>e</subscript> the same way the server did in steps <xref
        linkend="i1325557"/> and <xref linkend="i1325580"/>, and uses this to
        decrypt the encrypted response data. The <code>serverfg</code> value
        received in the response is used in the calculation.</para>

        <para><emphasis>r</emphasis> <phrase role="symbol">←</phrase>
        <emphasis>3DES</emphasis>(
        <emphasis>K</emphasis><subscript>e</subscript>,
        <emphasis>IV</emphasis>, <emphasis>e</emphasis>)</para>
      </listitem>

      <listitem>
        <para>The <emphasis>client</emphasis> performs the calculation of the
        MAC <emphasis>m'</emphasis> in the same way the server did, and checks
        that the results match the received MAC <emphasis>m</emphasis>. If
        they do not match, further processing is discarded. The
        <code>serverfg</code> value received in the response is used in the
        calculation.</para>

        <para><emphasis>K</emphasis><subscript>a</subscript> <phrase
        role="symbol">←</phrase> <emphasis>SHA1</emphasis>({<phrase
        role="symbol">δ</phrase>, <emphasis>c</emphasis>,
        <emphasis>s</emphasis>, <emphasis>A</emphasis>})</para>

        <para><emphasis>m'</emphasis> <phrase role="symbol">←</phrase>
        <emphasis>HMAC</emphasis>(
        <emphasis>K</emphasis><subscript>a</subscript>,
        <emphasis>e</emphasis>)</para>

        <para><emphasis>m' = m</emphasis></para>
      </listitem>
    </orderedlist>

    <figure>
      <title>Action Diagram for RSH</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" contentdepth="1.166in"
                     contentwidth="4.941in" fileref="rsh-action.svg"/>
        </imageobject>
      </mediaobject>
    </figure>

    <section>
      <title>Shared Secret</title>

      <para>The <emphasis>shared secret</emphasis> should be a key of length
      160 bits (20 bytes) or more. The length is selected to match the output
      of the selected hash algorithm <xref linkend="i1278847"/>.</para>

      <para>In some scenarios, the shared secret is generated by the Operator
      and communicated to the User, who inserts the secret into the OSGi
      framework through some unspecified means.</para>

      <para>The opposite is also possible: the shared secret can be stored
      within the OSGi framework, extracted from it, and then communicated to
      the Operator. In this scenario, the source of the shared secret could be
      either the OSGi framework or the Operator.</para>

      <para>In order for the server to calculate the authentication and
      encryption keys, it requires the proper shared secret. The server must
      have access to many different shared secrets, one for each OSGi
      framework it is to support. To be able to resolve this issue, the server
      must typically also have access to the OSGi framework Identifier of the
      OSGi framework. The normal way for the server to know the OSGi framework
      Identifier is through the application protocol, as this value is part of
      the URL encoded parameters of the HTTP, HTTPS, or RSH mapping of the
      Initial Provisioning.</para>

      <para>In order to be able to switch Operators, a new shared secret must
      be used. The new secret may be generated by the new Operator and then
      inserted into the OSGi framework device using a mechanism not covered by
      this specification. Or the device itself may generate the new secret and
      convey it to the owner of the device using a display device or read-out,
      which is then communicated to the new operator out-of-band.
      Additionally, the generation of the new secret may be triggered by some
      external event, like holding down a button for a specified amount of
      time.</para>
    </section>

    <section>
      <title>Request Coding</title>

      <para>RSH is mapped to HTTP or HTTPS. Thus, the request parameters are
      URL encoded as discussed in <xref linkend="i1297554"/>. RSH requires an
      additional parameter in the URL: the <code>clientfg</code> parameter.
      This parameter is a nonce that is used to counter replay attacks. See
      also <xref linkend="i1364615"/>.</para>
    </section>

    <section>
      <title>Response Coding</title>

      <para>The server's response to the client is composed of three
      parts:</para>

      <itemizedlist>
        <listitem>
          <para>A header containing the protocol version and the
          <code>serverfg</code></para>
        </listitem>

        <listitem>
          <para>The MAC</para>
        </listitem>

        <listitem>
          <para>The encrypted response</para>
        </listitem>
      </itemizedlist>

      <para>These three items are packaged into a binary container according
      to <xref linkend="service.provisioning-rsh.headers"/>.</para>

      <table xml:id="service.provisioning-rsh.headers">
        <title>RSH Header description</title>

        <tgroup cols="3">
          <colspec colnum="1" colwidth="1*"/>

          <colspec colnum="2" colwidth="4*"/>

          <colspec colnum="3" colwidth="1*"/>

          <thead>
            <row>
              <entry>Bytes</entry>

              <entry>Description</entry>

              <entry>Value hex</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><para>4</para></entry>

              <entry><para>Number of bytes in header</para></entry>

              <entry><para>2E</para></entry>
            </row>

            <row>
              <entry><para>1</para></entry>

              <entry><para>Major version number</para></entry>

              <entry><para>01</para></entry>
            </row>

            <row>
              <entry><para>1</para></entry>

              <entry><para>Minor version number</para></entry>

              <entry><para>00</para></entry>
            </row>

            <row>
              <entry><para>16</para></entry>

              <entry><para><code>serverfg</code></para></entry>

              <entry><para>...</para></entry>
            </row>

            <row>
              <entry><para>4</para></entry>

              <entry><para>Number of bytes in MAC</para></entry>

              <entry><para>10</para></entry>
            </row>

            <row>
              <entry><para>16</para></entry>

              <entry><para>Message Authentication Code</para></entry>

              <entry><para>MAC</para></entry>
            </row>

            <row>
              <entry><para>4</para></entry>

              <entry><para>Number of bytes of encrypted ZIP
              file</para></entry>

              <entry><para>N</para></entry>
            </row>

            <row>
              <entry><para>N</para></entry>

              <entry><para>Encrypted ZIP file</para></entry>

              <entry><para>...</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The response content type is an RSH-specific encrypted ZIP file,
      implying that the response header <code>Content-Type</code> must be
      <code>application/x-rsh</code> for the HTTP request. When the content
      file is decrypted, the content must be a ZIP file.</para>
    </section>

    <section>
      <title>RSH URL</title>

      <para>The RSH URL must be used internally within the OSGi framework to
      indicate the usage of RSH for initial provisioning. The RSH URL format
      is identical to the HTTP URL format, except that the scheme is
      <code>rsh:</code> instead of <code>http:</code>. For example (
      <code>«</code> means line continues on next line):</para>

      <programlisting>rsh://server.operator.com/service-x</programlisting>
    </section>

    <section>
      <title>Extensions to the Provisioning Service Dictionary</title>

      <para>RSH specifies one additional entry for the Provisioning
      Dictionary:</para>

      <programlisting><xref
          linkend="org.osgi.service.provisioning.ProvisioningService.PROVISIONING_RSH_SECRET"
          xrefstyle="hyperlink"/></programlisting>

      <para>The value of this entry is a <code>byte[]</code> containing the
      shared secret used by the RSH protocol.</para>
    </section>

    <section xml:id="i1364615">
      <title>RSH Transport</title>

      <para>RSH is mapped to HTTP or HTTPS and follows the same URL encoding
      rules, except that the <code>clientfg</code> is additionally appended to
      the URL. The key in the URL must be <code>clientfg</code> and the value
      must be encoded in base 64 format:</para>

      <para>The <code>clientfg</code> parameter is transported as an HTTP
      parameter that is appended after the <code>service_platform_id</code>
      parameter. The second example above would then be:</para>

      <programlisting>rsh://server.operator.com/service-x</programlisting>

      <para>Which, when mapped to HTTP, must become:</para>

      <programlisting>http://server.operator.com/service-x «
    service_platform_id=VIN:123456789&amp; «
    clientfg=AHPmWcw%2FsiWYC37xZNdKvQ%3D%3D</programlisting>
    </section>
  </section>

  <section>
    <title>Exception Handling</title>

    <para>The Initial Provisioning process is a sensitive process that must
    run without user supervision. There is therefore a need to handle
    exceptional cases in a well defined way to simplify trouble
    shooting.</para>

    <para>There are only 2 types of problems that halt the provisioning
    process. They are:</para>

    <itemizedlist>
      <listitem>
        <para>IO Exception when reading or writing provisioning
        information.</para>
      </listitem>

      <listitem>
        <para>IO Exception when retrieving or processing a provisioning zip
        file.</para>
      </listitem>
    </itemizedlist>

    <para>Other exceptions can occur and the Provisioning Service must do any
    attempt to log these events.</para>

    <para>In the cases that the provisioning process stops, it is important
    that the clients of the provisioning service have a way to find out that
    the process is stopped. The mechanism that is used for this is a special
    entry in the provisioning dictionary. The name of the entry must be
    <code>provisioning.error</code>. The value is a String object with the
    following format:</para>

    <itemizedlist>
      <listitem>
        <para>Numeric error code</para>
      </listitem>

      <listitem>
        <para>Space</para>
      </listitem>

      <listitem>
        <para>A human readable string describing the error.</para>
      </listitem>
    </itemizedlist>

    <para>Permitted error codes are:</para>

    <itemizedlist>
      <listitem>
        <para>0 - Unknown error</para>
      </listitem>

      <listitem>
        <para>1 - Couldn't load or save provisioning information</para>
      </listitem>

      <listitem>
        <para>2 - Malformed URL Exception</para>
      </listitem>

      <listitem>
        <para>3 - IO Exception when retrieving document of a URL</para>
      </listitem>

      <listitem>
        <para>4 - Corrupted Zip Input Stream</para>
      </listitem>
    </itemizedlist>

    <para>The provisioning.update.count will be incremented as normal when a
    <code>provisioning.error</code> entry is added to the provisioning
    information. After, the provisioning service will take no further
    action.</para>

    <para>Some examples:</para>

    <programlisting>0 SIM card removed
2 "http://www.acme.com/secure/blib/ifa.zip"</programlisting>
  </section>

  <section>
    <title>Security</title>

    <para>The security model for the OSGi framework is based on the integrity
    of the Management Agent deployment. If any of the mechanisms used during
    the deployment of management agents are weak, or can be compromised, the
    whole security model becomes weak.</para>

    <para>From a security perspective, one attractive means of information
    exchange would be a smart card. This approach enables all relevant
    information to be stored in a single place. The Operator could then
    provide the information to the OSGi framework by inserting the smart card
    into the OSGi framework.</para>

    <section>
      <title>Concerns</title>

      <para>The major security concerns related to the deployment of the
      Management Agent are:</para>

      <itemizedlist>
        <listitem>
          <para>The OSGi framework is controlled by the intended
          Operator</para>
        </listitem>

        <listitem>
          <para>The Operator controls the intended OSGi framework(s)</para>
        </listitem>

        <listitem>
          <para>The integrity and confidentiality of the information exchange
          that takes place during these processes must be considered</para>
        </listitem>
      </itemizedlist>

      <para>In order to address these concerns, an implementation of the OSGi
      Remote Management Architecture must assure that:</para>

      <itemizedlist>
        <listitem>
          <para>The Operator authenticates itself to the OSGi framework</para>
        </listitem>

        <listitem>
          <para>The OSGi framework authenticates itself to the Operator</para>
        </listitem>

        <listitem>
          <para>The integrity and confidentiality of the Management Agent,
          certificates, and configuration data are fully protected if they are
          transported over public transports.</para>
        </listitem>
      </itemizedlist>

      <para>Each mapping of the Initial Provisioning specification to a
      concrete implementation must describe how these goals are met.</para>
    </section>

    <section>
      <title>OSGi framework Long-Term Security</title>

      <para>Secrets for long-term use may be exchanged during the Initial
      Provisioning procedures. This way, one or more secrets may be shared
      securely, assuming that the Provisioning Dictionary assignments used are
      implemented with the proper security characteristics.</para>
    </section>

    <section>
      <title>Permissions</title>

      <para>The provisioning information may contain sensitive information.
      Also, the ability to modify provisioning information can have drastic
      consequences. Thus, only trusted bundles should be allowed to register,
      or get the Provisioning Service. This restriction can be enforced using
      <code>ServicePermission[ ProvisioningService, GET]</code>.</para>

      <para>No <code>Permission</code> classes guard reading or modification
      of the Provisioning Dictionary, so care must be taken not to leak the
      <code>Dictionary</code> object received from the Provisioning Service to
      bundles that are not trusted.</para>

      <para>Whether message-based or connection-based, the communications used
      for Initial Provisioning must support mutual authentication and message
      integrity checking, at a minimum.</para>

      <para>By using both server and client authentication in HTTPS, the
      problem of establishing identity is solved. In addition, HTTPS will
      encrypt the transmitted data. HTTPS requires a Public Key Infrastructure
      implementation in order to retrieve the required certificates.</para>

      <para>When RSH is used, it is vital that the shared secret is shared
      only between the Operator and the OSGi framework, and no one
      else.</para>
    </section>
  </section>

  <xi:include href="../../generated/javadoc/docbook/org.osgi.service.provisioning.xml"/>

  <section>
    <title>References</title>

    <bibliolist>
      <bibliomixed xml:id="i1327494"><title>HMAC: Keyed-Hashing for Message
      Authentication</title><biblioid class="uri"><link
      xlink:href="http://www.ietf.org/rfc/rfc2104.txt"/> Krawczyk ,et. al.
      1997</biblioid></bibliomixed>

      <bibliomixed xml:id="i1278847"><title>NIST, FIPS PUB 180-1: Secure Hash
      Standard, April 1995</title></bibliomixed>

      <bibliomixed><title>Hypertext Transfer Protocol -
      HTTP/1.1</title><biblioid class="uri"><link
      xlink:href="http://www.ietf.org/rfc/rfc2616.txt"/> Fielding, R., et.
      al.</biblioid></bibliomixed>

      <bibliomixed><title>Rescorla, E., HTTP over TLS, IETF RFC 2818, May
      2000</title><biblioid class="uri"><link
      xlink:href="http://www.ietf.org/rfc/rfc2818.txt"/></biblioid></bibliomixed>

      <bibliomixed xml:id="i1287017"><title>ZIP Archive
      format</title><biblioid class="uri"><link
      xlink:href="http://www.pkware.com/support/zip-app-note/archives"/></biblioid></bibliomixed>

      <bibliomixed xml:id="i1297476"><title>RFC 2396 - Uniform Resource
      Identifier (URI)</title><biblioid class="uri"><link
      xlink:href="http://www.ietf.org/rfc/rfc2396.txt"/></biblioid></bibliomixed>

      <bibliomixed xml:id="i1296602"><title>MIME Types</title><biblioid
      class="uri"><link
      xlink:href="http://www.ietf.org/rfc/rfc2046.txt"/></biblioid><?line-break ?><biblioid
      class="uri"><link
      xlink:href="http://www.iana.org/assignments/media-types"/></biblioid></bibliomixed>

      <bibliomixed xml:id="i1326320"><title>3DES</title>W/ Tuchman, "Hellman
      Presents No Shortcut Solution to DES," IEEE Spectrum, v. 16, n. 7 July
      1979, pp40-41</bibliomixed>

      <bibliomixed xml:id="i1371344"><title>RFC 1423 Part III: Algorithms,
      Modes, and Identifiers</title><biblioid class="uri"><link
      xlink:href="http://www.ietf.org/rfc/rfc1423.txt"/></biblioid></bibliomixed>

      <bibliomixed><title>PKCS 5</title><biblioid class="uri"><link
      xlink:href="ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-5v2"/></biblioid></bibliomixed>

      <bibliomixed xml:id="i1371440"><title>Java Cryptography API (part of
      Java 1.4)</title><biblioid class="uri"><link
      xlink:href="http://www.oracle.com/technetwork/java/javase/tech/index-jsp-136007.html/"/></biblioid></bibliomixed>

      <bibliomixed xml:id="i1371220"><title>SHA-1</title>U.S. Government,
      Proposed Federal Information Processing Standard for Secure Hash
      Standard, January 1992</bibliomixed>

      <bibliomixed><title>Transport Layer Security</title><biblioid
      class="uri"><link xlink:href="http://www.ietf.org/rfc/rfc2246.txt"/>,
      January 1999, The TLS Protocol Version 1.0, T. Dierks &amp; C.
      Allen</biblioid></bibliomixed>
    </bibliolist>
  </section>
</chapter>
